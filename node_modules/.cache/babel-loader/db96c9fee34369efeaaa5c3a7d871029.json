{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spread = this && this.__spread || function () {\n  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n\n  return ar;\n};\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nimport { Buffer } from 'buffer';\nimport { monotonicFactory } from 'ulid';\nimport { v4 as uuid } from 'uuid';\nimport { isPredicateGroup, isPredicateObj, SortDirection, isModelAttributeKey, isModelAttributePrimaryKey, isModelAttributeCompositeKey, LimitTimerRaceResolvedValues } from './types';\nimport { WordArray } from 'amazon-cognito-identity-js';\nexport var exhaustiveCheck = function (obj, throwOnError) {\n  if (throwOnError === void 0) {\n    throwOnError = true;\n  }\n\n  if (throwOnError) {\n    throw new Error(\"Invalid \" + obj);\n  }\n};\nexport var isNullOrUndefined = function (val) {\n  return typeof val === 'undefined' || val === undefined || val === null;\n};\nexport var validatePredicate = function (model, groupType, predicatesOrGroups) {\n  var filterType;\n  var isNegation = false;\n\n  if (predicatesOrGroups.length === 0) {\n    return true;\n  }\n\n  switch (groupType) {\n    case 'not':\n      filterType = 'every';\n      isNegation = true;\n      break;\n\n    case 'and':\n      filterType = 'every';\n      break;\n\n    case 'or':\n      filterType = 'some';\n      break;\n\n    default:\n      exhaustiveCheck(groupType);\n  }\n\n  var result = predicatesOrGroups[filterType](function (predicateOrGroup) {\n    if (isPredicateObj(predicateOrGroup)) {\n      var field = predicateOrGroup.field,\n          operator = predicateOrGroup.operator,\n          operand = predicateOrGroup.operand;\n      var value = model[field];\n      return validatePredicateField(value, operator, operand);\n    }\n\n    if (isPredicateGroup(predicateOrGroup)) {\n      var type = predicateOrGroup.type,\n          predicates = predicateOrGroup.predicates;\n      return validatePredicate(model, type, predicates);\n    }\n\n    throw new Error('Not a predicate or group');\n  });\n  return isNegation ? !result : result;\n};\nexport var validatePredicateField = function (value, operator, operand) {\n  switch (operator) {\n    case 'ne':\n      return value !== operand;\n\n    case 'eq':\n      return value === operand;\n\n    case 'le':\n      return value <= operand;\n\n    case 'lt':\n      return value < operand;\n\n    case 'ge':\n      return value >= operand;\n\n    case 'gt':\n      return value > operand;\n\n    case 'between':\n      var _c = __read(operand, 2),\n          min = _c[0],\n          max = _c[1];\n\n      return value >= min && value <= max;\n\n    case 'beginsWith':\n      return !isNullOrUndefined(value) && value.startsWith(operand);\n\n    case 'contains':\n      return !isNullOrUndefined(value) && value.indexOf(operand) > -1;\n\n    case 'notContains':\n      return isNullOrUndefined(value) || value.indexOf(operand) === -1;\n\n    default:\n      exhaustiveCheck(operator, false);\n      return false;\n  }\n};\nexport var isModelConstructor = function (obj) {\n  return obj && typeof obj.copyOf === 'function';\n};\nvar nonModelClasses = new WeakSet();\nexport function registerNonModelClass(clazz) {\n  nonModelClasses.add(clazz);\n}\nexport var isNonModelConstructor = function (obj) {\n  return nonModelClasses.has(obj);\n};\n/*\n  When we have GSI(s) with composite sort keys defined on a model\n    There are some very particular rules regarding which fields must be included in the update mutation input\n    The field selection becomes more complex as the number of GSIs with composite sort keys grows\n\n    To summarize: any time we update a field that is part of the composite sort key of a GSI, we must include:\n     1. all of the other fields in that composite sort key\n     2. all of the fields from any other composite sort key that intersect with the fields from 1.\n\n     E.g.,\n     Model @model\n        @key(name: 'key1' fields: ['hk', 'a', 'b', 'c'])\n        @key(name: 'key2' fields: ['hk', 'a', 'b', 'd'])\n        @key(name: 'key3' fields: ['hk', 'x', 'y', 'z'])\n\n    Model.a is updated => include ['a', 'b', 'c', 'd']\n    Model.c is updated => include ['a', 'b', 'c', 'd']\n    Model.d is updated => include ['a', 'b', 'c', 'd']\n    Model.x is updated => include ['x', 'y', 'z']\n\n    This function accepts a model's attributes and returns grouped sets of composite key fields\n    Using our example Model above, the function will return:\n    [\n        Set('a', 'b', 'c', 'd'),\n        Set('x', 'y', 'z'),\n    ]\n\n    This gives us the opportunity to correctly include the required fields for composite keys\n    When crafting the mutation input in Storage.getUpdateMutationInput\n\n    See 'processCompositeKeys' test in util.test.ts for more examples\n*/\n\nexport var processCompositeKeys = function (attributes) {\n  var extractCompositeSortKey = function (_c) {\n    var // ignore the HK (fields[0]) we only need to include the composite sort key fields[1...n]\n    _d = __read(_c.properties.fields),\n        sortKeyFields = _d.slice(1);\n\n    return sortKeyFields;\n  };\n\n  var compositeKeyFields = attributes.filter(isModelAttributeCompositeKey).map(extractCompositeSortKey);\n  /*\n      if 2 sets of fields have any intersecting fields => combine them into 1 union set\n      e.g., ['a', 'b', 'c'] and ['a', 'b', 'd'] => ['a', 'b', 'c', 'd']\n  */\n\n  var combineIntersecting = function (fields) {\n    return fields.reduce(function (combined, sortKeyFields) {\n      var sortKeyFieldsSet = new Set(sortKeyFields);\n\n      if (combined.length === 0) {\n        combined.push(sortKeyFieldsSet);\n        return combined;\n      } // does the current set share values with another set we've already added to `combined`?\n\n\n      var intersectingSetIdx = combined.findIndex(function (existingSet) {\n        return __spread(existingSet).some(function (f) {\n          return sortKeyFieldsSet.has(f);\n        });\n      });\n\n      if (intersectingSetIdx > -1) {\n        var union = new Set(__spread(combined[intersectingSetIdx], sortKeyFieldsSet)); // combine the current set with the intersecting set we found above\n\n        combined[intersectingSetIdx] = union;\n      } else {\n        // none of the sets in `combined` have intersecting values with the current set\n        combined.push(sortKeyFieldsSet);\n      }\n\n      return combined;\n    }, []);\n  };\n\n  var initial = combineIntersecting(compositeKeyFields); // a single pass pay not be enough to correctly combine all the fields\n  // call the function once more to get a final merged list of sets\n\n  var combined = combineIntersecting(initial);\n  return combined;\n};\nexport var establishRelationAndKeys = function (namespace) {\n  var relationship = {};\n  var keys = {};\n  Object.keys(namespace.models).forEach(function (mKey) {\n    var e_1, _c, e_2, _d;\n\n    relationship[mKey] = {\n      indexes: [],\n      relationTypes: []\n    };\n    keys[mKey] = {};\n    var model = namespace.models[mKey];\n    Object.keys(model.fields).forEach(function (attr) {\n      var fieldAttribute = model.fields[attr];\n\n      if (typeof fieldAttribute.type === 'object' && 'model' in fieldAttribute.type) {\n        var connectionType = fieldAttribute.association.connectionType;\n        relationship[mKey].relationTypes.push({\n          fieldName: fieldAttribute.name,\n          modelName: fieldAttribute.type.model,\n          relationType: connectionType,\n          targetName: fieldAttribute.association['targetName'],\n          associatedWith: fieldAttribute.association['associatedWith']\n        });\n\n        if (connectionType === 'BELONGS_TO') {\n          relationship[mKey].indexes.push(fieldAttribute.association['targetName']);\n        }\n      }\n    });\n\n    if (model.attributes) {\n      keys[mKey].compositeKeys = processCompositeKeys(model.attributes);\n\n      try {\n        for (var _e = __values(model.attributes), _f = _e.next(); !_f.done; _f = _e.next()) {\n          var attribute = _f.value;\n\n          if (!isModelAttributeKey(attribute)) {\n            continue;\n          }\n\n          if (isModelAttributePrimaryKey(attribute)) {\n            keys[mKey].primaryKey = attribute.properties.fields;\n          }\n\n          var fields = attribute.properties.fields;\n\n          try {\n            for (var fields_1 = (e_2 = void 0, __values(fields)), fields_1_1 = fields_1.next(); !fields_1_1.done; fields_1_1 = fields_1.next()) {\n              var field = fields_1_1.value; // only add index if it hasn't already been added\n\n              var exists = relationship[mKey].indexes.includes(field);\n\n              if (!exists) {\n                relationship[mKey].indexes.push(field);\n              }\n            }\n          } catch (e_2_1) {\n            e_2 = {\n              error: e_2_1\n            };\n          } finally {\n            try {\n              if (fields_1_1 && !fields_1_1.done && (_d = fields_1.return)) _d.call(fields_1);\n            } finally {\n              if (e_2) throw e_2.error;\n            }\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_f && !_f.done && (_c = _e.return)) _c.call(_e);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n  });\n  return [relationship, keys];\n};\nvar topologicallySortedModels = new WeakMap();\nexport var traverseModel = function (srcModelName, instance, namespace, modelInstanceCreator, getModelConstructorByModelName) {\n  var relationships = namespace.relationships;\n  var modelConstructor = getModelConstructorByModelName(namespace.name, srcModelName);\n  var relation = relationships[srcModelName];\n  var result = [];\n  var newInstance = modelConstructor.copyOf(instance, function (draftInstance) {\n    relation.relationTypes.forEach(function (rItem) {\n      var modelConstructor = getModelConstructorByModelName(namespace.name, rItem.modelName);\n\n      switch (rItem.relationType) {\n        case 'HAS_ONE':\n          if (instance[rItem.fieldName]) {\n            var modelInstance = void 0;\n\n            try {\n              modelInstance = modelInstanceCreator(modelConstructor, instance[rItem.fieldName]);\n            } catch (error) {\n              // Do nothing\n              console.log(error);\n            }\n\n            result.push({\n              modelName: rItem.modelName,\n              item: instance[rItem.fieldName],\n              instance: modelInstance\n            }); // targetName will be defined for Has One if feature flag\n            // https://docs.amplify.aws/cli/reference/feature-flags/#useAppsyncModelgenPlugin\n            // is true (default as of 5/7/21)\n            // Making this conditional for backward-compatibility\n\n            if (rItem.targetName) {\n              draftInstance[rItem.targetName] = draftInstance[rItem.fieldName].id;\n              delete draftInstance[rItem.fieldName];\n            } else {\n              draftInstance[rItem.fieldName] = draftInstance[rItem.fieldName].id;\n            }\n          }\n\n          break;\n\n        case 'BELONGS_TO':\n          if (instance[rItem.fieldName]) {\n            var modelInstance = void 0;\n\n            try {\n              modelInstance = modelInstanceCreator(modelConstructor, instance[rItem.fieldName]);\n            } catch (error) {// Do nothing\n            }\n\n            var isDeleted = draftInstance[rItem.fieldName]._deleted;\n\n            if (!isDeleted) {\n              result.push({\n                modelName: rItem.modelName,\n                item: instance[rItem.fieldName],\n                instance: modelInstance\n              });\n            }\n          }\n\n          if (draftInstance[rItem.fieldName]) {\n            draftInstance[rItem.targetName] = draftInstance[rItem.fieldName].id;\n            delete draftInstance[rItem.fieldName];\n          }\n\n          break;\n\n        case 'HAS_MANY':\n          // Intentionally blank\n          break;\n\n        default:\n          exhaustiveCheck(rItem.relationType);\n          break;\n      }\n    });\n  });\n  result.unshift({\n    modelName: srcModelName,\n    item: newInstance,\n    instance: newInstance\n  });\n\n  if (!topologicallySortedModels.has(namespace)) {\n    topologicallySortedModels.set(namespace, Array.from(namespace.modelTopologicalOrdering.keys()));\n  }\n\n  var sortedModels = topologicallySortedModels.get(namespace);\n  result.sort(function (a, b) {\n    return sortedModels.indexOf(a.modelName) - sortedModels.indexOf(b.modelName);\n  });\n  return result;\n};\nexport var getIndex = function (rel, src) {\n  var index = '';\n  rel.some(function (relItem) {\n    if (relItem.modelName === src) {\n      index = relItem.targetName;\n    }\n  });\n  return index;\n};\nexport var getIndexFromAssociation = function (indexes, src) {\n  var index = indexes.find(function (idx) {\n    return idx === src;\n  });\n  return index;\n};\nexport var NAMESPACES;\n\n(function (NAMESPACES) {\n  NAMESPACES[\"DATASTORE\"] = \"datastore\";\n  NAMESPACES[\"USER\"] = \"user\";\n  NAMESPACES[\"SYNC\"] = \"sync\";\n  NAMESPACES[\"STORAGE\"] = \"storage\";\n})(NAMESPACES || (NAMESPACES = {}));\n\nvar DATASTORE = NAMESPACES.DATASTORE;\nvar USER = NAMESPACES.USER;\nvar SYNC = NAMESPACES.SYNC;\nvar STORAGE = NAMESPACES.STORAGE;\nexport { USER, SYNC, STORAGE, DATASTORE };\nvar privateModeCheckResult;\nexport var isPrivateMode = function () {\n  return new Promise(function (resolve) {\n    var dbname = uuid();\n    var db;\n\n    var isPrivate = function () {\n      privateModeCheckResult = false;\n      resolve(true);\n    };\n\n    var isNotPrivate = function () {\n      return __awaiter(void 0, void 0, void 0, function () {\n        return __generator(this, function (_c) {\n          switch (_c.label) {\n            case 0:\n              if (!(db && db.result && typeof db.result.close === 'function')) return [3\n              /*break*/\n              , 2];\n              return [4\n              /*yield*/\n              , db.result.close()];\n\n            case 1:\n              _c.sent();\n\n              _c.label = 2;\n\n            case 2:\n              return [4\n              /*yield*/\n              , indexedDB.deleteDatabase(dbname)];\n\n            case 3:\n              _c.sent();\n\n              privateModeCheckResult = true;\n              return [2\n              /*return*/\n              , resolve(false)];\n          }\n        });\n      });\n    };\n\n    if (privateModeCheckResult === true) {\n      return isNotPrivate();\n    }\n\n    if (privateModeCheckResult === false) {\n      return isPrivate();\n    }\n\n    if (indexedDB === null) return isPrivate();\n    db = indexedDB.open(dbname);\n    db.onerror = isPrivate;\n    db.onsuccess = isNotPrivate;\n  });\n};\n\nvar randomBytes = function (nBytes) {\n  return Buffer.from(new WordArray().random(nBytes).toString(), 'hex');\n};\n\nvar prng = function () {\n  return randomBytes(1).readUInt8(0) / 0xff;\n};\n\nexport function monotonicUlidFactory(seed) {\n  var ulid = monotonicFactory(prng);\n  return function () {\n    return ulid(seed);\n  };\n}\n/**\n * Uses performance.now() if available, otherwise, uses Date.now() (e.g. react native without a polyfill)\n *\n * The values returned by performance.now() always increase at a constant rate,\n * independent of the system clock (which might be adjusted manually or skewed\n * by software like NTP).\n *\n * Otherwise, performance.timing.navigationStart + performance.now() will be\n * approximately equal to Date.now()\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/Performance/now#Example\n */\n\nexport function getNow() {\n  if (typeof performance !== 'undefined' && performance && typeof performance.now === 'function') {\n    return performance.now() | 0; // convert to integer\n  } else {\n    return Date.now();\n  }\n}\nexport function sortCompareFunction(sortPredicates) {\n  return function compareFunction(a, b) {\n    var e_3, _c;\n\n    try {\n      // enable multi-field sort by iterating over predicates until\n      // a comparison returns -1 or 1\n      for (var sortPredicates_1 = __values(sortPredicates), sortPredicates_1_1 = sortPredicates_1.next(); !sortPredicates_1_1.done; sortPredicates_1_1 = sortPredicates_1.next()) {\n        var predicate = sortPredicates_1_1.value;\n        var field = predicate.field,\n            sortDirection = predicate.sortDirection; // reverse result when direction is descending\n\n        var sortMultiplier = sortDirection === SortDirection.ASCENDING ? 1 : -1;\n\n        if (a[field] < b[field]) {\n          return -1 * sortMultiplier;\n        }\n\n        if (a[field] > b[field]) {\n          return 1 * sortMultiplier;\n        }\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (sortPredicates_1_1 && !sortPredicates_1_1.done && (_c = sortPredicates_1.return)) _c.call(sortPredicates_1);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n\n    return 0;\n  };\n} // deep compare any 2 values\n// primitives or object types (including arrays, Sets, and Maps)\n// returns true if equal by value\n// if nullish is true, treat undefined and null values as equal\n// to normalize for GQL response values for undefined fields\n\nexport function valuesEqual(valA, valB, nullish) {\n  var e_4, _c;\n\n  if (nullish === void 0) {\n    nullish = false;\n  }\n\n  var a = valA;\n  var b = valB;\n\n  var nullishCompare = function (_a, _b) {\n    return (_a === undefined || _a === null) && (_b === undefined || _b === null);\n  }; // if one of the values is a primitive and the other is an object\n\n\n  if (a instanceof Object && !(b instanceof Object) || !(a instanceof Object) && b instanceof Object) {\n    return false;\n  } // compare primitive types\n\n\n  if (!(a instanceof Object)) {\n    if (nullish && nullishCompare(a, b)) {\n      return true;\n    }\n\n    return a === b;\n  } // make sure object types match\n\n\n  if (Array.isArray(a) && !Array.isArray(b) || Array.isArray(b) && !Array.isArray(a)) {\n    return false;\n  }\n\n  if (a instanceof Set && b instanceof Set) {\n    a = __spread(a);\n    b = __spread(b);\n  }\n\n  if (a instanceof Map && b instanceof Map) {\n    a = Object.fromEntries(a);\n    b = Object.fromEntries(b);\n  }\n\n  var aKeys = Object.keys(a);\n  var bKeys = Object.keys(b); // last condition is to ensure that [] !== [null] even if nullish. However [undefined] === [null] when nullish\n\n  if (aKeys.length !== bKeys.length && (!nullish || Array.isArray(a))) {\n    return false;\n  } // iterate through the longer set of keys\n  // e.g., for a nullish comparison of a={ a: 1 } and b={ a: 1, b: null }\n  // we want to iterate through bKeys\n\n\n  var keys = aKeys.length >= bKeys.length ? aKeys : bKeys;\n\n  try {\n    for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {\n      var key = keys_1_1.value;\n      var aVal = a[key];\n      var bVal = b[key];\n\n      if (!valuesEqual(aVal, bVal, nullish)) {\n        return false;\n      }\n    }\n  } catch (e_4_1) {\n    e_4 = {\n      error: e_4_1\n    };\n  } finally {\n    try {\n      if (keys_1_1 && !keys_1_1.done && (_c = keys_1.return)) _c.call(keys_1);\n    } finally {\n      if (e_4) throw e_4.error;\n    }\n  }\n\n  return true;\n}\nexport var isAWSDate = function (val) {\n  return !!/^\\d{4}-\\d{2}-\\d{2}(Z|[+-]\\d{2}:\\d{2}($|:\\d{2}))?$/.exec(val);\n};\nexport var isAWSTime = function (val) {\n  return !!/^\\d{2}:\\d{2}(:\\d{2}(.\\d+)?)?(Z|[+-]\\d{2}:\\d{2}($|:\\d{2}))?$/.exec(val);\n};\nexport var isAWSDateTime = function (val) {\n  return !!/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}(:\\d{2}(.\\d+)?)?(Z|[+-]\\d{2}:\\d{2}($|:\\d{2}))?$/.exec(val);\n};\nexport var isAWSTimestamp = function (val) {\n  return !!/^\\d+$/.exec(String(val));\n};\nexport var isAWSEmail = function (val) {\n  return !!/^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.exec(val);\n};\nexport var isAWSJSON = function (val) {\n  try {\n    JSON.parse(val);\n    return true;\n  } catch (_c) {\n    return false;\n  }\n};\nexport var isAWSURL = function (val) {\n  try {\n    return !!new URL(val);\n  } catch (_c) {\n    return false;\n  }\n};\nexport var isAWSPhone = function (val) {\n  return !!/^\\+?\\d[\\d\\s-]+$/.exec(val);\n};\nexport var isAWSIPAddress = function (val) {\n  return !!/((^((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))$)|(^((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?$))$/.exec(val);\n};\n\nvar DeferredPromise =\n/** @class */\nfunction () {\n  function DeferredPromise() {\n    var self = this;\n    this.promise = new Promise(function (resolve, reject) {\n      self.resolve = resolve;\n      self.reject = reject;\n    });\n  }\n\n  return DeferredPromise;\n}();\n\nexport { DeferredPromise };\n\nvar DeferredCallbackResolver =\n/** @class */\nfunction () {\n  function DeferredCallbackResolver(options) {\n    this.limitPromise = new DeferredPromise();\n    this.raceInFlight = false;\n\n    this.callback = function () {};\n\n    this.defaultErrorHandler = function (msg) {\n      if (msg === void 0) {\n        msg = 'DeferredCallbackResolver error';\n      }\n\n      throw new Error(msg);\n    };\n\n    this.callback = options.callback;\n    this.errorHandler = options.errorHandler || this.defaultErrorHandler;\n    this.maxInterval = options.maxInterval || 2000;\n  }\n\n  DeferredCallbackResolver.prototype.startTimer = function () {\n    var _this = this;\n\n    this.timerPromise = new Promise(function (resolve, reject) {\n      _this.timer = setTimeout(function () {\n        resolve(LimitTimerRaceResolvedValues.TIMER);\n      }, _this.maxInterval);\n    });\n  };\n\n  DeferredCallbackResolver.prototype.racePromises = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var winner, err_1;\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            _c.trys.push([0, 2, 3, 4]);\n\n            this.raceInFlight = true;\n            this.startTimer();\n            return [4\n            /*yield*/\n            , Promise.race([this.timerPromise, this.limitPromise.promise])];\n\n          case 1:\n            winner = _c.sent();\n            this.callback();\n            return [3\n            /*break*/\n            , 4];\n\n          case 2:\n            err_1 = _c.sent();\n            this.errorHandler(err_1);\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            // reset for the next race\n            this.clear();\n            this.raceInFlight = false;\n            this.limitPromise = new DeferredPromise();\n            return [2\n            /*return*/\n            , winner];\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  DeferredCallbackResolver.prototype.start = function () {\n    if (!this.raceInFlight) this.racePromises();\n  };\n\n  DeferredCallbackResolver.prototype.clear = function () {\n    clearTimeout(this.timer);\n  };\n\n  DeferredCallbackResolver.prototype.resolve = function () {\n    this.limitPromise.resolve(LimitTimerRaceResolvedValues.LIMIT);\n  };\n\n  return DeferredCallbackResolver;\n}();\n\nexport { DeferredCallbackResolver };","map":{"version":3,"mappings":"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","names":["Buffer","monotonicFactory","v4","uuid","isPredicateGroup","isPredicateObj","SortDirection","isModelAttributeKey","isModelAttributePrimaryKey","isModelAttributeCompositeKey","LimitTimerRaceResolvedValues","WordArray","exhaustiveCheck","obj","throwOnError","Error","isNullOrUndefined","val","undefined","validatePredicate","model","groupType","predicatesOrGroups","filterType","isNegation","length","result","predicateOrGroup","operator","operand","value","field","validatePredicateField","predicates","type","min","max","startsWith","indexOf","isModelConstructor","copyOf","nonModelClasses","WeakSet","registerNonModelClass","clazz","add","isNonModelConstructor","has","processCompositeKeys","attributes","extractCompositeSortKey","_c","_d","sortKeyFields","compositeKeyFields","filter","map","combineIntersecting","fields","reduce","combined","sortKeyFieldsSet","Set","push","intersectingSetIdx","findIndex","__spread","existingSet","some","f","union","initial","establishRelationAndKeys","namespace","relationship","keys","Object","models","forEach","mKey","indexes","relationTypes","attr","fieldAttribute","connectionType","association","fieldName","name","modelName","relationType","targetName","associatedWith","compositeKeys","_f","attribute","primaryKey","properties","fields_1_1","exists","includes","topologicallySortedModels","WeakMap","traverseModel","srcModelName","instance","modelInstanceCreator","getModelConstructorByModelName","relationships","modelConstructor","relation","newInstance","rItem","modelInstance","error","console","log","item","draftInstance","id","isDeleted","_deleted","unshift","set","Array","from","modelTopologicalOrdering","sortedModels","get","sort","a","b","getIndex","rel","src","index","relItem","getIndexFromAssociation","find","NAMESPACES","DATASTORE","USER","SYNC","STORAGE","privateModeCheckResult","isPrivateMode","Promise","dbname","db","isPrivate","resolve","isNotPrivate","close","indexedDB","deleteDatabase","open","onerror","onsuccess","randomBytes","nBytes","random","toString","prng","readUInt8","monotonicUlidFactory","seed","ulid","getNow","performance","now","Date","sortCompareFunction","sortPredicates","compareFunction","sortPredicates_1_1","predicate","sortDirection","sortMultiplier","ASCENDING","valuesEqual","valA","valB","nullish","nullishCompare","_a","_b","isArray","Map","fromEntries","aKeys","bKeys","keys_1_1","key","aVal","bVal","isAWSDate","exec","isAWSTime","isAWSDateTime","isAWSTimestamp","String","isAWSEmail","isAWSJSON","JSON","parse","isAWSURL","URL","isAWSPhone","isAWSIPAddress","self","promise","reject","options","DeferredPromise","msg","callback","errorHandler","defaultErrorHandler","maxInterval","DeferredCallbackResolver","timerPromise","_this","timer","setTimeout","TIMER","raceInFlight","startTimer","race","limitPromise","winner","err_1","clear","racePromises","clearTimeout","LIMIT"],"sources":["/Users/richards/node_modules/@aws-amplify/datastore/src/util.ts"],"sourcesContent":["import { Buffer } from 'buffer';\nimport { monotonicFactory, ULID } from 'ulid';\nimport { v4 as uuid } from 'uuid';\nimport { ModelInstanceCreator } from './datastore/datastore';\nimport {\n\tAllOperators,\n\tisPredicateGroup,\n\tisPredicateObj,\n\tModelInstanceMetadata,\n\tPersistentModel,\n\tPersistentModelConstructor,\n\tPredicateGroups,\n\tPredicateObject,\n\tPredicatesGroup,\n\tRelationshipType,\n\tRelationType,\n\tModelKeys,\n\tModelAttributes,\n\tSchemaNamespace,\n\tSortPredicatesGroup,\n\tSortDirection,\n\tisModelAttributeKey,\n\tisModelAttributePrimaryKey,\n\tisModelAttributeCompositeKey,\n\tNonModelTypeConstructor,\n\tDeferredCallbackResolverOptions,\n\tLimitTimerRaceResolvedValues,\n} from './types';\nimport { WordArray } from 'amazon-cognito-identity-js';\n\nexport const exhaustiveCheck = (obj: never, throwOnError: boolean = true) => {\n\tif (throwOnError) {\n\t\tthrow new Error(`Invalid ${obj}`);\n\t}\n};\n\nexport const isNullOrUndefined = (val: any): boolean => {\n\treturn typeof val === 'undefined' || val === undefined || val === null;\n};\n\nexport const validatePredicate = <T extends PersistentModel>(\n\tmodel: T,\n\tgroupType: keyof PredicateGroups<T>,\n\tpredicatesOrGroups: (PredicateObject<T> | PredicatesGroup<T>)[]\n) => {\n\tlet filterType: keyof Pick<any[], 'every' | 'some'>;\n\tlet isNegation = false;\n\n\tif (predicatesOrGroups.length === 0) {\n\t\treturn true;\n\t}\n\n\tswitch (groupType) {\n\t\tcase 'not':\n\t\t\tfilterType = 'every';\n\t\t\tisNegation = true;\n\t\t\tbreak;\n\t\tcase 'and':\n\t\t\tfilterType = 'every';\n\t\t\tbreak;\n\t\tcase 'or':\n\t\t\tfilterType = 'some';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\texhaustiveCheck(groupType);\n\t}\n\n\tconst result: boolean = predicatesOrGroups[filterType](predicateOrGroup => {\n\t\tif (isPredicateObj(predicateOrGroup)) {\n\t\t\tconst { field, operator, operand } = predicateOrGroup;\n\t\t\tconst value = model[field];\n\n\t\t\treturn validatePredicateField(value, operator, operand);\n\t\t}\n\n\t\tif (isPredicateGroup(predicateOrGroup)) {\n\t\t\tconst { type, predicates } = predicateOrGroup;\n\t\t\treturn validatePredicate(model, type, predicates);\n\t\t}\n\n\t\tthrow new Error('Not a predicate or group');\n\t});\n\n\treturn isNegation ? !result : result;\n};\n\nexport const validatePredicateField = <T>(\n\tvalue: T,\n\toperator: keyof AllOperators,\n\toperand: T | [T, T]\n) => {\n\tswitch (operator) {\n\t\tcase 'ne':\n\t\t\treturn value !== operand;\n\t\tcase 'eq':\n\t\t\treturn value === operand;\n\t\tcase 'le':\n\t\t\treturn value <= operand;\n\t\tcase 'lt':\n\t\t\treturn value < operand;\n\t\tcase 'ge':\n\t\t\treturn value >= operand;\n\t\tcase 'gt':\n\t\t\treturn value > operand;\n\t\tcase 'between':\n\t\t\tconst [min, max] = <[T, T]>operand;\n\t\t\treturn value >= min && value <= max;\n\t\tcase 'beginsWith':\n\t\t\treturn (\n\t\t\t\t!isNullOrUndefined(value) &&\n\t\t\t\t(<string>(<unknown>value)).startsWith(<string>(<unknown>operand))\n\t\t\t);\n\t\tcase 'contains':\n\t\t\treturn (\n\t\t\t\t!isNullOrUndefined(value) &&\n\t\t\t\t(<string>(<unknown>value)).indexOf(<string>(<unknown>operand)) > -1\n\t\t\t);\n\t\tcase 'notContains':\n\t\t\treturn (\n\t\t\t\tisNullOrUndefined(value) ||\n\t\t\t\t(<string>(<unknown>value)).indexOf(<string>(<unknown>operand)) === -1\n\t\t\t);\n\t\tdefault:\n\t\t\texhaustiveCheck(operator, false);\n\t\t\treturn false;\n\t}\n};\n\nexport const isModelConstructor = <T extends PersistentModel>(\n\tobj: any\n): obj is PersistentModelConstructor<T> => {\n\treturn (\n\t\tobj && typeof (<PersistentModelConstructor<T>>obj).copyOf === 'function'\n\t);\n};\n\nconst nonModelClasses = new WeakSet<NonModelTypeConstructor<any>>();\n\nexport function registerNonModelClass(clazz: NonModelTypeConstructor<any>) {\n\tnonModelClasses.add(clazz);\n}\n\nexport const isNonModelConstructor = (\n\tobj: any\n): obj is NonModelTypeConstructor<any> => {\n\treturn nonModelClasses.has(obj);\n};\n\n/* \n  When we have GSI(s) with composite sort keys defined on a model\n\tThere are some very particular rules regarding which fields must be included in the update mutation input\n\tThe field selection becomes more complex as the number of GSIs with composite sort keys grows\n\n\tTo summarize: any time we update a field that is part of the composite sort key of a GSI, we must include:\n\t 1. all of the other fields in that composite sort key\n\t 2. all of the fields from any other composite sort key that intersect with the fields from 1.\n\n\t E.g.,\n\t Model @model \n\t\t@key(name: 'key1' fields: ['hk', 'a', 'b', 'c'])\n\t\t@key(name: 'key2' fields: ['hk', 'a', 'b', 'd'])\n\t\t@key(name: 'key3' fields: ['hk', 'x', 'y', 'z'])\n\n\tModel.a is updated => include ['a', 'b', 'c', 'd']\n\tModel.c is updated => include ['a', 'b', 'c', 'd']\n\tModel.d is updated => include ['a', 'b', 'c', 'd']\n\tModel.x is updated => include ['x', 'y', 'z']\n\n\tThis function accepts a model's attributes and returns grouped sets of composite key fields\n\tUsing our example Model above, the function will return:\n\t[\n\t\tSet('a', 'b', 'c', 'd'),\n\t\tSet('x', 'y', 'z'),\n\t]\n\n\tThis gives us the opportunity to correctly include the required fields for composite keys\n\tWhen crafting the mutation input in Storage.getUpdateMutationInput\n\n\tSee 'processCompositeKeys' test in util.test.ts for more examples\n*/\nexport const processCompositeKeys = (\n\tattributes: ModelAttributes\n): Set<string>[] => {\n\tconst extractCompositeSortKey = ({\n\t\tproperties: {\n\t\t\t// ignore the HK (fields[0]) we only need to include the composite sort key fields[1...n]\n\t\t\tfields: [, ...sortKeyFields],\n\t\t},\n\t}) => sortKeyFields;\n\n\tconst compositeKeyFields = attributes\n\t\t.filter(isModelAttributeCompositeKey)\n\t\t.map(extractCompositeSortKey);\n\n\t/* \n\t\tif 2 sets of fields have any intersecting fields => combine them into 1 union set\n\t\te.g., ['a', 'b', 'c'] and ['a', 'b', 'd'] => ['a', 'b', 'c', 'd']\n\t*/\n\tconst combineIntersecting = (fields): Set<string>[] =>\n\t\tfields.reduce((combined, sortKeyFields) => {\n\t\t\tconst sortKeyFieldsSet = new Set(sortKeyFields);\n\n\t\t\tif (combined.length === 0) {\n\t\t\t\tcombined.push(sortKeyFieldsSet);\n\t\t\t\treturn combined;\n\t\t\t}\n\n\t\t\t// does the current set share values with another set we've already added to `combined`?\n\t\t\tconst intersectingSetIdx = combined.findIndex(existingSet => {\n\t\t\t\treturn [...existingSet].some(f => sortKeyFieldsSet.has(f));\n\t\t\t});\n\n\t\t\tif (intersectingSetIdx > -1) {\n\t\t\t\tconst union = new Set([\n\t\t\t\t\t...combined[intersectingSetIdx],\n\t\t\t\t\t...sortKeyFieldsSet,\n\t\t\t\t]);\n\t\t\t\t// combine the current set with the intersecting set we found above\n\t\t\t\tcombined[intersectingSetIdx] = union;\n\t\t\t} else {\n\t\t\t\t// none of the sets in `combined` have intersecting values with the current set\n\t\t\t\tcombined.push(sortKeyFieldsSet);\n\t\t\t}\n\n\t\t\treturn combined;\n\t\t}, []);\n\n\tconst initial = combineIntersecting(compositeKeyFields);\n\t// a single pass pay not be enough to correctly combine all the fields\n\t// call the function once more to get a final merged list of sets\n\tconst combined = combineIntersecting(initial);\n\n\treturn combined;\n};\n\nexport const establishRelationAndKeys = (\n\tnamespace: SchemaNamespace\n): [RelationshipType, ModelKeys] => {\n\tconst relationship: RelationshipType = {};\n\tconst keys: ModelKeys = {};\n\n\tObject.keys(namespace.models).forEach((mKey: string) => {\n\t\trelationship[mKey] = { indexes: [], relationTypes: [] };\n\t\tkeys[mKey] = {};\n\n\t\tconst model = namespace.models[mKey];\n\t\tObject.keys(model.fields).forEach((attr: string) => {\n\t\t\tconst fieldAttribute = model.fields[attr];\n\t\t\tif (\n\t\t\t\ttypeof fieldAttribute.type === 'object' &&\n\t\t\t\t'model' in fieldAttribute.type\n\t\t\t) {\n\t\t\t\tconst connectionType = fieldAttribute.association.connectionType;\n\t\t\t\trelationship[mKey].relationTypes.push({\n\t\t\t\t\tfieldName: fieldAttribute.name,\n\t\t\t\t\tmodelName: fieldAttribute.type.model,\n\t\t\t\t\trelationType: connectionType,\n\t\t\t\t\ttargetName: fieldAttribute.association['targetName'],\n\t\t\t\t\tassociatedWith: fieldAttribute.association['associatedWith'],\n\t\t\t\t});\n\n\t\t\t\tif (connectionType === 'BELONGS_TO') {\n\t\t\t\t\trelationship[mKey].indexes.push(\n\t\t\t\t\t\tfieldAttribute.association['targetName']\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tif (model.attributes) {\n\t\t\tkeys[mKey].compositeKeys = processCompositeKeys(model.attributes);\n\n\t\t\tfor (const attribute of model.attributes) {\n\t\t\t\tif (!isModelAttributeKey(attribute)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (isModelAttributePrimaryKey(attribute)) {\n\t\t\t\t\tkeys[mKey].primaryKey = attribute.properties.fields;\n\t\t\t\t}\n\n\t\t\t\tconst { fields } = attribute.properties;\n\t\t\t\tfor (const field of fields) {\n\t\t\t\t\t// only add index if it hasn't already been added\n\t\t\t\t\tconst exists = relationship[mKey].indexes.includes(field);\n\t\t\t\t\tif (!exists) {\n\t\t\t\t\t\trelationship[mKey].indexes.push(field);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\treturn [relationship, keys];\n};\n\nconst topologicallySortedModels = new WeakMap<SchemaNamespace, string[]>();\n\nexport const traverseModel = <T extends PersistentModel>(\n\tsrcModelName: string,\n\tinstance: T,\n\tnamespace: SchemaNamespace,\n\tmodelInstanceCreator: ModelInstanceCreator,\n\tgetModelConstructorByModelName: (\n\t\tnamsespaceName: string,\n\t\tmodelName: string\n\t) => PersistentModelConstructor<any>\n) => {\n\tconst relationships = namespace.relationships;\n\tconst modelConstructor = getModelConstructorByModelName(\n\t\tnamespace.name,\n\t\tsrcModelName\n\t);\n\n\tconst relation = relationships[srcModelName];\n\tconst result: {\n\t\tmodelName: string;\n\t\titem: T;\n\t\tinstance: T;\n\t}[] = [];\n\n\tconst newInstance = modelConstructor.copyOf(instance, draftInstance => {\n\t\trelation.relationTypes.forEach((rItem: RelationType) => {\n\t\t\tconst modelConstructor = getModelConstructorByModelName(\n\t\t\t\tnamespace.name,\n\t\t\t\trItem.modelName\n\t\t\t);\n\n\t\t\tswitch (rItem.relationType) {\n\t\t\t\tcase 'HAS_ONE':\n\t\t\t\t\tif (instance[rItem.fieldName]) {\n\t\t\t\t\t\tlet modelInstance: T;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tmodelInstance = modelInstanceCreator(\n\t\t\t\t\t\t\t\tmodelConstructor,\n\t\t\t\t\t\t\t\tinstance[rItem.fieldName]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t// Do nothing\n\t\t\t\t\t\t\tconsole.log(error);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresult.push({\n\t\t\t\t\t\t\tmodelName: rItem.modelName,\n\t\t\t\t\t\t\titem: instance[rItem.fieldName],\n\t\t\t\t\t\t\tinstance: modelInstance,\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// targetName will be defined for Has One if feature flag\n\t\t\t\t\t\t// https://docs.amplify.aws/cli/reference/feature-flags/#useAppsyncModelgenPlugin\n\t\t\t\t\t\t// is true (default as of 5/7/21)\n\t\t\t\t\t\t// Making this conditional for backward-compatibility\n\t\t\t\t\t\tif (rItem.targetName) {\n\t\t\t\t\t\t\t(<any>draftInstance)[rItem.targetName] = (<PersistentModel>(\n\t\t\t\t\t\t\t\tdraftInstance[rItem.fieldName]\n\t\t\t\t\t\t\t)).id;\n\t\t\t\t\t\t\tdelete draftInstance[rItem.fieldName];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t(<any>draftInstance)[rItem.fieldName] = (<PersistentModel>(\n\t\t\t\t\t\t\t\tdraftInstance[rItem.fieldName]\n\t\t\t\t\t\t\t)).id;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'BELONGS_TO':\n\t\t\t\t\tif (instance[rItem.fieldName]) {\n\t\t\t\t\t\tlet modelInstance: T;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tmodelInstance = modelInstanceCreator(\n\t\t\t\t\t\t\t\tmodelConstructor,\n\t\t\t\t\t\t\t\tinstance[rItem.fieldName]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t// Do nothing\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst isDeleted = (<ModelInstanceMetadata>(\n\t\t\t\t\t\t\tdraftInstance[rItem.fieldName]\n\t\t\t\t\t\t))._deleted;\n\n\t\t\t\t\t\tif (!isDeleted) {\n\t\t\t\t\t\t\tresult.push({\n\t\t\t\t\t\t\t\tmodelName: rItem.modelName,\n\t\t\t\t\t\t\t\titem: instance[rItem.fieldName],\n\t\t\t\t\t\t\t\tinstance: modelInstance,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (draftInstance[rItem.fieldName]) {\n\t\t\t\t\t\t(<any>draftInstance)[rItem.targetName] = (<PersistentModel>(\n\t\t\t\t\t\t\tdraftInstance[rItem.fieldName]\n\t\t\t\t\t\t)).id;\n\t\t\t\t\t\tdelete draftInstance[rItem.fieldName];\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'HAS_MANY':\n\t\t\t\t\t// Intentionally blank\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\texhaustiveCheck(rItem.relationType);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\t});\n\n\tresult.unshift({\n\t\tmodelName: srcModelName,\n\t\titem: newInstance,\n\t\tinstance: newInstance,\n\t});\n\n\tif (!topologicallySortedModels.has(namespace)) {\n\t\ttopologicallySortedModels.set(\n\t\t\tnamespace,\n\t\t\tArray.from(namespace.modelTopologicalOrdering.keys())\n\t\t);\n\t}\n\n\tconst sortedModels = topologicallySortedModels.get(namespace);\n\n\tresult.sort((a, b) => {\n\t\treturn (\n\t\t\tsortedModels.indexOf(a.modelName) - sortedModels.indexOf(b.modelName)\n\t\t);\n\t});\n\n\treturn result;\n};\n\nexport const getIndex = (rel: RelationType[], src: string): string => {\n\tlet index = '';\n\trel.some((relItem: RelationType) => {\n\t\tif (relItem.modelName === src) {\n\t\t\tindex = relItem.targetName;\n\t\t}\n\t});\n\treturn index;\n};\n\nexport const getIndexFromAssociation = (\n\tindexes: string[],\n\tsrc: string\n): string => {\n\tconst index = indexes.find(idx => idx === src);\n\treturn index;\n};\n\nexport enum NAMESPACES {\n\tDATASTORE = 'datastore',\n\tUSER = 'user',\n\tSYNC = 'sync',\n\tSTORAGE = 'storage',\n}\n\nconst DATASTORE = NAMESPACES.DATASTORE;\nconst USER = NAMESPACES.USER;\nconst SYNC = NAMESPACES.SYNC;\nconst STORAGE = NAMESPACES.STORAGE;\n\nexport { USER, SYNC, STORAGE, DATASTORE };\n\nlet privateModeCheckResult;\n\nexport const isPrivateMode = () => {\n\treturn new Promise(resolve => {\n\t\tconst dbname = uuid();\n\t\tlet db;\n\n\t\tconst isPrivate = () => {\n\t\t\tprivateModeCheckResult = false;\n\n\t\t\tresolve(true);\n\t\t};\n\n\t\tconst isNotPrivate = async () => {\n\t\t\tif (db && db.result && typeof db.result.close === 'function') {\n\t\t\t\tawait db.result.close();\n\t\t\t}\n\n\t\t\tawait indexedDB.deleteDatabase(dbname);\n\n\t\t\tprivateModeCheckResult = true;\n\n\t\t\treturn resolve(false);\n\t\t};\n\n\t\tif (privateModeCheckResult === true) {\n\t\t\treturn isNotPrivate();\n\t\t}\n\n\t\tif (privateModeCheckResult === false) {\n\t\t\treturn isPrivate();\n\t\t}\n\n\t\tif (indexedDB === null) return isPrivate();\n\n\t\tdb = indexedDB.open(dbname);\n\t\tdb.onerror = isPrivate;\n\t\tdb.onsuccess = isNotPrivate;\n\t});\n};\n\nconst randomBytes = (nBytes: number): Buffer => {\n\treturn Buffer.from(new WordArray().random(nBytes).toString(), 'hex');\n};\nconst prng = () => randomBytes(1).readUInt8(0) / 0xff;\nexport function monotonicUlidFactory(seed?: number): ULID {\n\tconst ulid = monotonicFactory(prng);\n\n\treturn () => {\n\t\treturn ulid(seed);\n\t};\n}\n\n/**\n * Uses performance.now() if available, otherwise, uses Date.now() (e.g. react native without a polyfill)\n *\n * The values returned by performance.now() always increase at a constant rate,\n * independent of the system clock (which might be adjusted manually or skewed\n * by software like NTP).\n *\n * Otherwise, performance.timing.navigationStart + performance.now() will be\n * approximately equal to Date.now()\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/Performance/now#Example\n */\nexport function getNow() {\n\tif (\n\t\ttypeof performance !== 'undefined' &&\n\t\tperformance &&\n\t\ttypeof performance.now === 'function'\n\t) {\n\t\treturn performance.now() | 0; // convert to integer\n\t} else {\n\t\treturn Date.now();\n\t}\n}\n\nexport function sortCompareFunction<T extends PersistentModel>(\n\tsortPredicates: SortPredicatesGroup<T>\n) {\n\treturn function compareFunction(a, b) {\n\t\t// enable multi-field sort by iterating over predicates until\n\t\t// a comparison returns -1 or 1\n\t\tfor (const predicate of sortPredicates) {\n\t\t\tconst { field, sortDirection } = predicate;\n\n\t\t\t// reverse result when direction is descending\n\t\t\tconst sortMultiplier = sortDirection === SortDirection.ASCENDING ? 1 : -1;\n\n\t\t\tif (a[field] < b[field]) {\n\t\t\t\treturn -1 * sortMultiplier;\n\t\t\t}\n\n\t\t\tif (a[field] > b[field]) {\n\t\t\t\treturn 1 * sortMultiplier;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t};\n}\n\n// deep compare any 2 values\n// primitives or object types (including arrays, Sets, and Maps)\n// returns true if equal by value\n// if nullish is true, treat undefined and null values as equal\n// to normalize for GQL response values for undefined fields\nexport function valuesEqual(\n\tvalA: any,\n\tvalB: any,\n\tnullish: boolean = false\n): boolean {\n\tlet a = valA;\n\tlet b = valB;\n\n\tconst nullishCompare = (_a, _b) => {\n\t\treturn (\n\t\t\t(_a === undefined || _a === null) && (_b === undefined || _b === null)\n\t\t);\n\t};\n\n\t// if one of the values is a primitive and the other is an object\n\tif (\n\t\t(a instanceof Object && !(b instanceof Object)) ||\n\t\t(!(a instanceof Object) && b instanceof Object)\n\t) {\n\t\treturn false;\n\t}\n\n\t// compare primitive types\n\tif (!(a instanceof Object)) {\n\t\tif (nullish && nullishCompare(a, b)) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn a === b;\n\t}\n\n\t// make sure object types match\n\tif (\n\t\t(Array.isArray(a) && !Array.isArray(b)) ||\n\t\t(Array.isArray(b) && !Array.isArray(a))\n\t) {\n\t\treturn false;\n\t}\n\n\tif (a instanceof Set && b instanceof Set) {\n\t\ta = [...a];\n\t\tb = [...b];\n\t}\n\n\tif (a instanceof Map && b instanceof Map) {\n\t\ta = Object.fromEntries(a);\n\t\tb = Object.fromEntries(b);\n\t}\n\n\tconst aKeys = Object.keys(a);\n\tconst bKeys = Object.keys(b);\n\n\t// last condition is to ensure that [] !== [null] even if nullish. However [undefined] === [null] when nullish\n\tif (aKeys.length !== bKeys.length && (!nullish || Array.isArray(a))) {\n\t\treturn false;\n\t}\n\n\t// iterate through the longer set of keys\n\t// e.g., for a nullish comparison of a={ a: 1 } and b={ a: 1, b: null }\n\t// we want to iterate through bKeys\n\tconst keys = aKeys.length >= bKeys.length ? aKeys : bKeys;\n\n\tfor (const key of keys) {\n\t\tconst aVal = a[key];\n\t\tconst bVal = b[key];\n\n\t\tif (!valuesEqual(aVal, bVal, nullish)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nexport const isAWSDate = (val: string): boolean => {\n\treturn !!/^\\d{4}-\\d{2}-\\d{2}(Z|[+-]\\d{2}:\\d{2}($|:\\d{2}))?$/.exec(val);\n};\n\nexport const isAWSTime = (val: string): boolean => {\n\treturn !!/^\\d{2}:\\d{2}(:\\d{2}(.\\d+)?)?(Z|[+-]\\d{2}:\\d{2}($|:\\d{2}))?$/.exec(\n\t\tval\n\t);\n};\n\nexport const isAWSDateTime = (val: string): boolean => {\n\treturn !!/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}(:\\d{2}(.\\d+)?)?(Z|[+-]\\d{2}:\\d{2}($|:\\d{2}))?$/.exec(\n\t\tval\n\t);\n};\n\nexport const isAWSTimestamp = (val: number): boolean => {\n\treturn !!/^\\d+$/.exec(String(val));\n};\n\nexport const isAWSEmail = (val: string): boolean => {\n\treturn !!/^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.exec(\n\t\tval\n\t);\n};\n\nexport const isAWSJSON = (val: string): boolean => {\n\ttry {\n\t\tJSON.parse(val);\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n};\n\nexport const isAWSURL = (val: string): boolean => {\n\ttry {\n\t\treturn !!new URL(val);\n\t} catch {\n\t\treturn false;\n\t}\n};\n\nexport const isAWSPhone = (val: string): boolean => {\n\treturn !!/^\\+?\\d[\\d\\s-]+$/.exec(val);\n};\n\nexport const isAWSIPAddress = (val: string): boolean => {\n\treturn !!/((^((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))$)|(^((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?$))$/.exec(\n\t\tval\n\t);\n};\n\nexport class DeferredPromise {\n\tpublic promise: Promise<string>;\n\tpublic resolve: (value: string | PromiseLike<string>) => void;\n\tpublic reject: () => void;\n\tconstructor() {\n\t\tconst self = this;\n\t\tthis.promise = new Promise(\n\t\t\t(resolve: (value: string | PromiseLike<string>) => void, reject) => {\n\t\t\t\tself.resolve = resolve;\n\t\t\t\tself.reject = reject;\n\t\t\t}\n\t\t);\n\t}\n}\n\nexport class DeferredCallbackResolver {\n\tprivate limitPromise = new DeferredPromise();\n\tprivate timerPromise: Promise<string>;\n\tprivate maxInterval: number;\n\tprivate timer: ReturnType<typeof setTimeout>;\n\tprivate raceInFlight = false;\n\tprivate callback = () => {};\n\tprivate errorHandler: (error: string) => void;\n\tprivate defaultErrorHandler = (\n\t\tmsg = 'DeferredCallbackResolver error'\n\t): void => {\n\t\tthrow new Error(msg);\n\t};\n\n\tconstructor(options: DeferredCallbackResolverOptions) {\n\t\tthis.callback = options.callback;\n\t\tthis.errorHandler = options.errorHandler || this.defaultErrorHandler;\n\t\tthis.maxInterval = options.maxInterval || 2000;\n\t}\n\n\tprivate startTimer(): void {\n\t\tthis.timerPromise = new Promise((resolve, reject) => {\n\t\t\tthis.timer = setTimeout(() => {\n\t\t\t\tresolve(LimitTimerRaceResolvedValues.TIMER);\n\t\t\t}, this.maxInterval);\n\t\t});\n\t}\n\n\tprivate async racePromises(): Promise<string> {\n\t\tlet winner: string;\n\t\ttry {\n\t\t\tthis.raceInFlight = true;\n\t\t\tthis.startTimer();\n\t\t\twinner = await Promise.race([\n\t\t\t\tthis.timerPromise,\n\t\t\t\tthis.limitPromise.promise,\n\t\t\t]);\n\t\t\tthis.callback();\n\t\t} catch (err) {\n\t\t\tthis.errorHandler(err);\n\t\t} finally {\n\t\t\t// reset for the next race\n\t\t\tthis.clear();\n\t\t\tthis.raceInFlight = false;\n\t\t\tthis.limitPromise = new DeferredPromise();\n\n\t\t\treturn winner;\n\t\t}\n\t}\n\n\tpublic start(): void {\n\t\tif (!this.raceInFlight) this.racePromises();\n\t}\n\n\tpublic clear(): void {\n\t\tclearTimeout(this.timer);\n\t}\n\n\tpublic resolve(): void {\n\t\tthis.limitPromise.resolve(LimitTimerRaceResolvedValues.LIMIT);\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}