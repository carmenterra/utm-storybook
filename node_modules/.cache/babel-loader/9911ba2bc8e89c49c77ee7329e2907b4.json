{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n/*\n * Copyright 2017-2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n *     http://aws.amazon.com/apache2.0/\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\n\n\nimport Observable from 'zen-observable-ts';\nimport { GraphQLError } from 'graphql';\nimport * as url from 'url';\nimport { v4 as uuid } from 'uuid';\nimport { Buffer } from 'buffer';\nimport { Logger, Credentials, Signer, Hub, Constants, USER_AGENT_HEADER, jitteredExponentialRetry, NonRetryableError } from '@aws-amplify/core';\nimport Cache from '@aws-amplify/cache';\nimport Auth from '@aws-amplify/auth';\nimport { AbstractPubSubProvider } from './PubSubProvider';\nimport { CONTROL_MSG } from '../index';\nvar logger = new Logger('AWSAppSyncRealTimeProvider');\nvar AMPLIFY_SYMBOL = typeof Symbol !== 'undefined' && typeof Symbol.for === 'function' ? Symbol.for('amplify_default') : '@@amplify_default';\n\nvar dispatchApiEvent = function (event, data, message) {\n  Hub.dispatch('api', {\n    event: event,\n    data: data,\n    message: message\n  }, 'PubSub', AMPLIFY_SYMBOL);\n};\n\nvar MAX_DELAY_MS = 5000;\nvar NON_RETRYABLE_CODES = [400, 401, 403];\nvar MESSAGE_TYPES;\n\n(function (MESSAGE_TYPES) {\n  /**\n   * Client -> Server message.\n   * This message type is the first message after handshake and this will initialize AWS AppSync RealTime communication\n   */\n  MESSAGE_TYPES[\"GQL_CONNECTION_INIT\"] = \"connection_init\";\n  /**\n   * Server -> Client message\n   * This message type is in case there is an issue with AWS AppSync RealTime when establishing connection\n   */\n\n  MESSAGE_TYPES[\"GQL_CONNECTION_ERROR\"] = \"connection_error\";\n  /**\n   * Server -> Client message.\n   * This message type is for the ack response from AWS AppSync RealTime for GQL_CONNECTION_INIT message\n   */\n\n  MESSAGE_TYPES[\"GQL_CONNECTION_ACK\"] = \"connection_ack\";\n  /**\n   * Client -> Server message.\n   * This message type is for register subscriptions with AWS AppSync RealTime\n   */\n\n  MESSAGE_TYPES[\"GQL_START\"] = \"start\";\n  /**\n   * Server -> Client message.\n   * This message type is for the ack response from AWS AppSync RealTime for GQL_START message\n   */\n\n  MESSAGE_TYPES[\"GQL_START_ACK\"] = \"start_ack\";\n  /**\n   * Server -> Client message.\n   * This message type is for subscription message from AWS AppSync RealTime\n   */\n\n  MESSAGE_TYPES[\"GQL_DATA\"] = \"data\";\n  /**\n   * Server -> Client message.\n   * This message type helps the client to know is still receiving messages from AWS AppSync RealTime\n   */\n\n  MESSAGE_TYPES[\"GQL_CONNECTION_KEEP_ALIVE\"] = \"ka\";\n  /**\n   * Client -> Server message.\n   * This message type is for unregister subscriptions with AWS AppSync RealTime\n   */\n\n  MESSAGE_TYPES[\"GQL_STOP\"] = \"stop\";\n  /**\n   * Server -> Client message.\n   * This message type is for the ack response from AWS AppSync RealTime for GQL_STOP message\n   */\n\n  MESSAGE_TYPES[\"GQL_COMPLETE\"] = \"complete\";\n  /**\n   * Server -> Client message.\n   * This message type is for sending error messages from AWS AppSync RealTime to the client\n   */\n\n  MESSAGE_TYPES[\"GQL_ERROR\"] = \"error\";\n})(MESSAGE_TYPES || (MESSAGE_TYPES = {}));\n\nvar SUBSCRIPTION_STATUS;\n\n(function (SUBSCRIPTION_STATUS) {\n  SUBSCRIPTION_STATUS[SUBSCRIPTION_STATUS[\"PENDING\"] = 0] = \"PENDING\";\n  SUBSCRIPTION_STATUS[SUBSCRIPTION_STATUS[\"CONNECTED\"] = 1] = \"CONNECTED\";\n  SUBSCRIPTION_STATUS[SUBSCRIPTION_STATUS[\"FAILED\"] = 2] = \"FAILED\";\n})(SUBSCRIPTION_STATUS || (SUBSCRIPTION_STATUS = {}));\n\nvar SOCKET_STATUS;\n\n(function (SOCKET_STATUS) {\n  SOCKET_STATUS[SOCKET_STATUS[\"CLOSED\"] = 0] = \"CLOSED\";\n  SOCKET_STATUS[SOCKET_STATUS[\"READY\"] = 1] = \"READY\";\n  SOCKET_STATUS[SOCKET_STATUS[\"CONNECTING\"] = 2] = \"CONNECTING\";\n})(SOCKET_STATUS || (SOCKET_STATUS = {}));\n\nvar AWS_APPSYNC_REALTIME_HEADERS = {\n  accept: 'application/json, text/javascript',\n  'content-encoding': 'amz-1.0',\n  'content-type': 'application/json; charset=UTF-8'\n};\n/**\n * Time in milleseconds to wait for GQL_CONNECTION_INIT message\n */\n\nvar CONNECTION_INIT_TIMEOUT = 15000;\n/**\n * Time in milleseconds to wait for GQL_START_ACK message\n */\n\nvar START_ACK_TIMEOUT = 15000;\n/**\n * Default Time in milleseconds to wait for GQL_CONNECTION_KEEP_ALIVE message\n */\n\nvar DEFAULT_KEEP_ALIVE_TIMEOUT = 5 * 60 * 1000;\nvar standardDomainPattern = /^https:\\/\\/\\w{26}\\.appsync\\-api\\.\\w{2}(?:(?:\\-\\w{2,})+)\\-\\d\\.amazonaws.com\\/graphql$/i;\nvar customDomainPath = '/realtime';\n\nvar AWSAppSyncRealTimeProvider =\n/** @class */\nfunction (_super) {\n  __extends(AWSAppSyncRealTimeProvider, _super);\n\n  function AWSAppSyncRealTimeProvider() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.socketStatus = SOCKET_STATUS.CLOSED;\n    _this.keepAliveTimeout = DEFAULT_KEEP_ALIVE_TIMEOUT;\n    _this.subscriptionObserverMap = new Map();\n    _this.promiseArray = [];\n    return _this;\n  }\n\n  AWSAppSyncRealTimeProvider.prototype.getProviderName = function () {\n    return 'AWSAppSyncRealTimeProvider';\n  };\n\n  AWSAppSyncRealTimeProvider.prototype.newClient = function () {\n    throw new Error('Not used here');\n  };\n\n  AWSAppSyncRealTimeProvider.prototype.publish = function (_topics, _msg, _options) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        throw new Error('Operation not supported');\n      });\n    });\n  }; // Check if url matches standard domain pattern\n\n\n  AWSAppSyncRealTimeProvider.prototype.isCustomDomain = function (url) {\n    return url.match(standardDomainPattern) === null;\n  };\n\n  AWSAppSyncRealTimeProvider.prototype.subscribe = function (_topics, options) {\n    var _this = this;\n\n    var appSyncGraphqlEndpoint = options.appSyncGraphqlEndpoint;\n    return new Observable(function (observer) {\n      if (!appSyncGraphqlEndpoint) {\n        observer.error({\n          errors: [__assign({}, new GraphQLError(\"Subscribe only available for AWS AppSync endpoint\"))]\n        });\n        observer.complete();\n      } else {\n        var subscriptionId_1 = uuid();\n\n        _this._startSubscriptionWithAWSAppSyncRealTime({\n          options: options,\n          observer: observer,\n          subscriptionId: subscriptionId_1\n        }).catch(function (err) {\n          observer.error({\n            errors: [__assign({}, new GraphQLError(CONTROL_MSG.REALTIME_SUBSCRIPTION_INIT_ERROR + \": \" + err))]\n          });\n          observer.complete();\n        });\n\n        return function () {\n          return __awaiter(_this, void 0, void 0, function () {\n            var subscriptionState, err_1;\n            return __generator(this, function (_a) {\n              switch (_a.label) {\n                case 0:\n                  _a.trys.push([0, 2, 3, 4]); // Waiting that subscription has been connected before trying to unsubscribe\n\n\n                  return [4\n                  /*yield*/\n                  , this._waitForSubscriptionToBeConnected(subscriptionId_1)];\n\n                case 1:\n                  // Waiting that subscription has been connected before trying to unsubscribe\n                  _a.sent();\n\n                  subscriptionState = (this.subscriptionObserverMap.get(subscriptionId_1) || {}).subscriptionState;\n\n                  if (!subscriptionState) {\n                    // subscription already unsubscribed\n                    return [2\n                    /*return*/\n                    ];\n                  }\n\n                  if (subscriptionState === SUBSCRIPTION_STATUS.CONNECTED) {\n                    this._sendUnsubscriptionMessage(subscriptionId_1);\n                  } else {\n                    throw new Error('Subscription never connected');\n                  }\n\n                  return [3\n                  /*break*/\n                  , 4];\n\n                case 2:\n                  err_1 = _a.sent();\n                  logger.debug(\"Error while unsubscribing \" + err_1);\n                  return [3\n                  /*break*/\n                  , 4];\n\n                case 3:\n                  this._removeSubscriptionObserver(subscriptionId_1);\n\n                  return [7\n                  /*endfinally*/\n                  ];\n\n                case 4:\n                  return [2\n                  /*return*/\n                  ];\n              }\n            });\n          });\n        };\n      }\n    });\n  };\n\n  Object.defineProperty(AWSAppSyncRealTimeProvider.prototype, \"isSSLEnabled\", {\n    get: function () {\n      return !this.options.aws_appsync_dangerously_connect_to_http_endpoint_for_testing;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  AWSAppSyncRealTimeProvider.prototype._startSubscriptionWithAWSAppSyncRealTime = function (_a) {\n    var options = _a.options,\n        observer = _a.observer,\n        subscriptionId = _a.subscriptionId;\n    return __awaiter(this, void 0, void 0, function () {\n      var appSyncGraphqlEndpoint, authenticationType, query, variables, apiKey, region, _b, graphql_headers, _c, additionalHeaders, subscriptionState, data, dataString, headerObj, _d, _e, subscriptionMessage, stringToAWSRealTime, err_2, _f, message, subscriptionFailedCallback_1, _g, subscriptionFailedCallback, subscriptionReadyCallback;\n\n      var _h;\n\n      var _this = this;\n\n      return __generator(this, function (_j) {\n        switch (_j.label) {\n          case 0:\n            appSyncGraphqlEndpoint = options.appSyncGraphqlEndpoint, authenticationType = options.authenticationType, query = options.query, variables = options.variables, apiKey = options.apiKey, region = options.region, _b = options.graphql_headers, graphql_headers = _b === void 0 ? function () {\n              return {};\n            } : _b, _c = options.additionalHeaders, additionalHeaders = _c === void 0 ? {} : _c;\n            subscriptionState = SUBSCRIPTION_STATUS.PENDING;\n            data = {\n              query: query,\n              variables: variables\n            }; // Having a subscription id map will make it simple to forward messages received\n\n            this.subscriptionObserverMap.set(subscriptionId, {\n              observer: observer,\n              query: query,\n              variables: variables,\n              subscriptionState: subscriptionState,\n              startAckTimeoutId: null\n            });\n            dataString = JSON.stringify(data);\n            _d = [{}];\n            return [4\n            /*yield*/\n            , this._awsRealTimeHeaderBasedAuth({\n              apiKey: apiKey,\n              appSyncGraphqlEndpoint: appSyncGraphqlEndpoint,\n              authenticationType: authenticationType,\n              payload: dataString,\n              canonicalUri: '',\n              region: region,\n              additionalHeaders: additionalHeaders\n            })];\n\n          case 1:\n            _e = [__assign.apply(void 0, _d.concat([_j.sent()]))];\n            return [4\n            /*yield*/\n            , graphql_headers()];\n\n          case 2:\n            headerObj = __assign.apply(void 0, [__assign.apply(void 0, [__assign.apply(void 0, _e.concat([_j.sent()])), additionalHeaders]), (_h = {}, _h[USER_AGENT_HEADER] = Constants.userAgent, _h)]);\n            subscriptionMessage = {\n              id: subscriptionId,\n              payload: {\n                data: dataString,\n                extensions: {\n                  authorization: __assign({}, headerObj)\n                }\n              },\n              type: MESSAGE_TYPES.GQL_START\n            };\n            stringToAWSRealTime = JSON.stringify(subscriptionMessage);\n            _j.label = 3;\n\n          case 3:\n            _j.trys.push([3, 5,, 6]);\n\n            return [4\n            /*yield*/\n            , this._initializeWebSocketConnection({\n              apiKey: apiKey,\n              appSyncGraphqlEndpoint: appSyncGraphqlEndpoint,\n              authenticationType: authenticationType,\n              region: region,\n              additionalHeaders: additionalHeaders\n            })];\n\n          case 4:\n            _j.sent();\n\n            return [3\n            /*break*/\n            , 6];\n\n          case 5:\n            err_2 = _j.sent();\n            logger.debug({\n              err: err_2\n            });\n            _f = err_2.message, message = _f === void 0 ? '' : _f;\n            observer.error({\n              errors: [__assign({}, new GraphQLError(CONTROL_MSG.CONNECTION_FAILED + \": \" + message))]\n            });\n            observer.complete();\n            subscriptionFailedCallback_1 = (this.subscriptionObserverMap.get(subscriptionId) || {}).subscriptionFailedCallback; // Notify concurrent unsubscription\n\n            if (typeof subscriptionFailedCallback_1 === 'function') {\n              subscriptionFailedCallback_1();\n            }\n\n            return [2\n            /*return*/\n            ];\n\n          case 6:\n            _g = this.subscriptionObserverMap.get(subscriptionId), subscriptionFailedCallback = _g.subscriptionFailedCallback, subscriptionReadyCallback = _g.subscriptionReadyCallback; // This must be done before sending the message in order to be listening immediately\n\n            this.subscriptionObserverMap.set(subscriptionId, {\n              observer: observer,\n              subscriptionState: subscriptionState,\n              variables: variables,\n              query: query,\n              subscriptionReadyCallback: subscriptionReadyCallback,\n              subscriptionFailedCallback: subscriptionFailedCallback,\n              startAckTimeoutId: setTimeout(function () {\n                _this._timeoutStartSubscriptionAck.call(_this, subscriptionId);\n              }, START_ACK_TIMEOUT)\n            });\n\n            if (this.awsRealTimeSocket) {\n              this.awsRealTimeSocket.send(stringToAWSRealTime);\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }; // Waiting that subscription has been connected before trying to unsubscribe\n\n\n  AWSAppSyncRealTimeProvider.prototype._waitForSubscriptionToBeConnected = function (subscriptionId) {\n    return __awaiter(this, void 0, void 0, function () {\n      var subscriptionState;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        subscriptionState = this.subscriptionObserverMap.get(subscriptionId).subscriptionState; // This in case unsubscribe is invoked before sending start subscription message\n\n        if (subscriptionState === SUBSCRIPTION_STATUS.PENDING) {\n          return [2\n          /*return*/\n          , new Promise(function (res, rej) {\n            var _a = _this.subscriptionObserverMap.get(subscriptionId),\n                observer = _a.observer,\n                subscriptionState = _a.subscriptionState,\n                variables = _a.variables,\n                query = _a.query;\n\n            _this.subscriptionObserverMap.set(subscriptionId, {\n              observer: observer,\n              subscriptionState: subscriptionState,\n              variables: variables,\n              query: query,\n              subscriptionReadyCallback: res,\n              subscriptionFailedCallback: rej\n            });\n          })];\n        }\n\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n\n  AWSAppSyncRealTimeProvider.prototype._sendUnsubscriptionMessage = function (subscriptionId) {\n    try {\n      if (this.awsRealTimeSocket && this.awsRealTimeSocket.readyState === WebSocket.OPEN && this.socketStatus === SOCKET_STATUS.READY) {\n        // Preparing unsubscribe message to stop receiving messages for that subscription\n        var unsubscribeMessage = {\n          id: subscriptionId,\n          type: MESSAGE_TYPES.GQL_STOP\n        };\n        var stringToAWSRealTime = JSON.stringify(unsubscribeMessage);\n        this.awsRealTimeSocket.send(stringToAWSRealTime);\n      }\n    } catch (err) {\n      // If GQL_STOP is not sent because of disconnection issue, then there is nothing the client can do\n      logger.debug({\n        err: err\n      });\n    }\n  };\n\n  AWSAppSyncRealTimeProvider.prototype._removeSubscriptionObserver = function (subscriptionId) {\n    this.subscriptionObserverMap.delete(subscriptionId); // Verifying 1000ms after removing subscription in case there are new subscription unmount/mount\n\n    setTimeout(this._closeSocketIfRequired.bind(this), 1000);\n  };\n\n  AWSAppSyncRealTimeProvider.prototype._closeSocketIfRequired = function () {\n    if (this.subscriptionObserverMap.size > 0) {\n      // Active subscriptions on the WebSocket\n      return;\n    }\n\n    if (!this.awsRealTimeSocket) {\n      this.socketStatus = SOCKET_STATUS.CLOSED;\n      return;\n    }\n\n    if (this.awsRealTimeSocket.bufferedAmount > 0) {\n      // Still data on the WebSocket\n      setTimeout(this._closeSocketIfRequired.bind(this), 1000);\n    } else {\n      logger.debug('closing WebSocket...');\n      clearTimeout(this.keepAliveTimeoutId);\n      var tempSocket = this.awsRealTimeSocket; // Cleaning callbacks to avoid race condition, socket still exists\n\n      tempSocket.onclose = undefined;\n      tempSocket.onerror = undefined;\n      tempSocket.close(1000);\n      this.awsRealTimeSocket = null;\n      this.socketStatus = SOCKET_STATUS.CLOSED;\n    }\n  };\n\n  AWSAppSyncRealTimeProvider.prototype._handleIncomingSubscriptionMessage = function (message) {\n    logger.debug(\"subscription message from AWS AppSync RealTime: \" + message.data);\n\n    var _a = JSON.parse(message.data),\n        _b = _a.id,\n        id = _b === void 0 ? '' : _b,\n        payload = _a.payload,\n        type = _a.type;\n\n    var _c = this.subscriptionObserverMap.get(id) || {},\n        _d = _c.observer,\n        observer = _d === void 0 ? null : _d,\n        _e = _c.query,\n        query = _e === void 0 ? '' : _e,\n        _f = _c.variables,\n        variables = _f === void 0 ? {} : _f,\n        startAckTimeoutId = _c.startAckTimeoutId,\n        subscriptionReadyCallback = _c.subscriptionReadyCallback,\n        subscriptionFailedCallback = _c.subscriptionFailedCallback;\n\n    logger.debug({\n      id: id,\n      observer: observer,\n      query: query,\n      variables: variables\n    });\n\n    if (type === MESSAGE_TYPES.GQL_DATA && payload && payload.data) {\n      if (observer) {\n        observer.next(payload);\n      } else {\n        logger.debug(\"observer not found for id: \" + id);\n      }\n\n      return;\n    }\n\n    if (type === MESSAGE_TYPES.GQL_START_ACK) {\n      logger.debug(\"subscription ready for \" + JSON.stringify({\n        query: query,\n        variables: variables\n      }));\n\n      if (typeof subscriptionReadyCallback === 'function') {\n        subscriptionReadyCallback();\n      }\n\n      clearTimeout(startAckTimeoutId);\n      dispatchApiEvent(CONTROL_MSG.SUBSCRIPTION_ACK, {\n        query: query,\n        variables: variables\n      }, 'Connection established for subscription');\n      var subscriptionState = SUBSCRIPTION_STATUS.CONNECTED;\n      this.subscriptionObserverMap.set(id, {\n        observer: observer,\n        query: query,\n        variables: variables,\n        startAckTimeoutId: null,\n        subscriptionState: subscriptionState,\n        subscriptionReadyCallback: subscriptionReadyCallback,\n        subscriptionFailedCallback: subscriptionFailedCallback\n      }); // TODO: emit event on hub but it requires to store the id first\n\n      return;\n    }\n\n    if (type === MESSAGE_TYPES.GQL_CONNECTION_KEEP_ALIVE) {\n      clearTimeout(this.keepAliveTimeoutId);\n      this.keepAliveTimeoutId = setTimeout(this._errorDisconnect.bind(this, CONTROL_MSG.TIMEOUT_DISCONNECT), this.keepAliveTimeout);\n      return;\n    }\n\n    if (type === MESSAGE_TYPES.GQL_ERROR) {\n      var subscriptionState = SUBSCRIPTION_STATUS.FAILED;\n      this.subscriptionObserverMap.set(id, {\n        observer: observer,\n        query: query,\n        variables: variables,\n        startAckTimeoutId: startAckTimeoutId,\n        subscriptionReadyCallback: subscriptionReadyCallback,\n        subscriptionFailedCallback: subscriptionFailedCallback,\n        subscriptionState: subscriptionState\n      });\n      observer.error({\n        errors: [__assign({}, new GraphQLError(CONTROL_MSG.CONNECTION_FAILED + \": \" + JSON.stringify(payload)))]\n      });\n      clearTimeout(startAckTimeoutId);\n      observer.complete();\n\n      if (typeof subscriptionFailedCallback === 'function') {\n        subscriptionFailedCallback();\n      }\n    }\n  };\n\n  AWSAppSyncRealTimeProvider.prototype._errorDisconnect = function (msg) {\n    logger.debug(\"Disconnect error: \" + msg);\n    this.subscriptionObserverMap.forEach(function (_a) {\n      var observer = _a.observer;\n\n      if (observer && !observer.closed) {\n        observer.error({\n          errors: [__assign({}, new GraphQLError(msg))]\n        });\n      }\n    });\n    this.subscriptionObserverMap.clear();\n\n    if (this.awsRealTimeSocket) {\n      this.awsRealTimeSocket.close();\n    }\n\n    this.socketStatus = SOCKET_STATUS.CLOSED;\n  };\n\n  AWSAppSyncRealTimeProvider.prototype._timeoutStartSubscriptionAck = function (subscriptionId) {\n    var _a = this.subscriptionObserverMap.get(subscriptionId) || {},\n        observer = _a.observer,\n        query = _a.query,\n        variables = _a.variables;\n\n    if (!observer) {\n      return;\n    }\n\n    this.subscriptionObserverMap.set(subscriptionId, {\n      observer: observer,\n      query: query,\n      variables: variables,\n      subscriptionState: SUBSCRIPTION_STATUS.FAILED\n    });\n\n    if (observer && !observer.closed) {\n      observer.error({\n        errors: [__assign({}, new GraphQLError(\"Subscription timeout \" + JSON.stringify({\n          query: query,\n          variables: variables\n        })))]\n      }); // Cleanup will be automatically executed\n\n      observer.complete();\n    }\n\n    logger.debug('timeoutStartSubscription', JSON.stringify({\n      query: query,\n      variables: variables\n    }));\n  };\n\n  AWSAppSyncRealTimeProvider.prototype._initializeWebSocketConnection = function (_a) {\n    var _this = this;\n\n    var appSyncGraphqlEndpoint = _a.appSyncGraphqlEndpoint,\n        authenticationType = _a.authenticationType,\n        apiKey = _a.apiKey,\n        region = _a.region,\n        additionalHeaders = _a.additionalHeaders;\n\n    if (this.socketStatus === SOCKET_STATUS.READY) {\n      return;\n    }\n\n    return new Promise(function (res, rej) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var payloadString, headerString, _a, _b, headerQs, payloadQs, discoverableEndpoint, protocol, awsRealTimeUrl, err_3;\n\n        return __generator(this, function (_c) {\n          switch (_c.label) {\n            case 0:\n              this.promiseArray.push({\n                res: res,\n                rej: rej\n              });\n              if (!(this.socketStatus === SOCKET_STATUS.CLOSED)) return [3\n              /*break*/\n              , 5];\n              _c.label = 1;\n\n            case 1:\n              _c.trys.push([1, 4,, 5]);\n\n              this.socketStatus = SOCKET_STATUS.CONNECTING;\n              payloadString = '{}';\n              _b = (_a = JSON).stringify;\n              return [4\n              /*yield*/\n              , this._awsRealTimeHeaderBasedAuth({\n                authenticationType: authenticationType,\n                payload: payloadString,\n                canonicalUri: '/connect',\n                apiKey: apiKey,\n                appSyncGraphqlEndpoint: appSyncGraphqlEndpoint,\n                region: region,\n                additionalHeaders: additionalHeaders\n              })];\n\n            case 2:\n              headerString = _b.apply(_a, [_c.sent()]);\n              headerQs = Buffer.from(headerString).toString('base64');\n              payloadQs = Buffer.from(payloadString).toString('base64');\n              discoverableEndpoint = appSyncGraphqlEndpoint;\n\n              if (this.isCustomDomain(discoverableEndpoint)) {\n                discoverableEndpoint = discoverableEndpoint.concat(customDomainPath);\n              } else {\n                discoverableEndpoint = discoverableEndpoint.replace('appsync-api', 'appsync-realtime-api').replace('gogi-beta', 'grt-beta');\n              }\n\n              protocol = this.isSSLEnabled ? 'wss://' : 'ws://';\n              discoverableEndpoint = discoverableEndpoint.replace('https://', protocol).replace('http://', protocol);\n              awsRealTimeUrl = discoverableEndpoint + \"?header=\" + headerQs + \"&payload=\" + payloadQs;\n              return [4\n              /*yield*/\n              , this._initializeRetryableHandshake({\n                awsRealTimeUrl: awsRealTimeUrl\n              })];\n\n            case 3:\n              _c.sent();\n\n              this.promiseArray.forEach(function (_a) {\n                var res = _a.res;\n                logger.debug('Notifying connection successful');\n                res();\n              });\n              this.socketStatus = SOCKET_STATUS.READY;\n              this.promiseArray = [];\n              return [3\n              /*break*/\n              , 5];\n\n            case 4:\n              err_3 = _c.sent();\n              this.promiseArray.forEach(function (_a) {\n                var rej = _a.rej;\n                return rej(err_3);\n              });\n              this.promiseArray = [];\n\n              if (this.awsRealTimeSocket && this.awsRealTimeSocket.readyState === WebSocket.OPEN) {\n                this.awsRealTimeSocket.close(3001);\n              }\n\n              this.awsRealTimeSocket = null;\n              this.socketStatus = SOCKET_STATUS.CLOSED;\n              return [3\n              /*break*/\n              , 5];\n\n            case 5:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    });\n  };\n\n  AWSAppSyncRealTimeProvider.prototype._initializeRetryableHandshake = function (_a) {\n    var awsRealTimeUrl = _a.awsRealTimeUrl;\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            logger.debug(\"Initializaling retryable Handshake\");\n            return [4\n            /*yield*/\n            , jitteredExponentialRetry(this._initializeHandshake.bind(this), [{\n              awsRealTimeUrl: awsRealTimeUrl\n            }], MAX_DELAY_MS)];\n\n          case 1:\n            _b.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  AWSAppSyncRealTimeProvider.prototype._initializeHandshake = function (_a) {\n    var awsRealTimeUrl = _a.awsRealTimeUrl;\n    return __awaiter(this, void 0, void 0, function () {\n      var err_4, errorType, errorCode;\n\n      var _this = this;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            logger.debug(\"Initializing handshake \" + awsRealTimeUrl);\n            _b.label = 1;\n\n          case 1:\n            _b.trys.push([1, 4,, 5]);\n\n            return [4\n            /*yield*/\n            , function () {\n              return new Promise(function (res, rej) {\n                var newSocket = new WebSocket(awsRealTimeUrl, 'graphql-ws');\n\n                newSocket.onerror = function () {\n                  logger.debug(\"WebSocket connection error\");\n                };\n\n                newSocket.onclose = function () {\n                  rej(new Error('Connection handshake error'));\n                };\n\n                newSocket.onopen = function () {\n                  _this.awsRealTimeSocket = newSocket;\n                  return res();\n                };\n              });\n            }()];\n\n          case 2:\n            _b.sent(); // Step 2: wait for ack from AWS AppSyncReaTime after sending init\n\n\n            return [4\n            /*yield*/\n            , function () {\n              return new Promise(function (res, rej) {\n                var ackOk = false;\n\n                _this.awsRealTimeSocket.onerror = function (error) {\n                  logger.debug(\"WebSocket error \" + JSON.stringify(error));\n                };\n\n                _this.awsRealTimeSocket.onclose = function (event) {\n                  logger.debug(\"WebSocket closed \" + event.reason);\n                  rej(new Error(JSON.stringify(event)));\n                };\n\n                _this.awsRealTimeSocket.onmessage = function (message) {\n                  logger.debug(\"subscription message from AWS AppSyncRealTime: \" + message.data + \" \");\n                  var data = JSON.parse(message.data);\n                  var type = data.type,\n                      _a = data.payload,\n                      _b = (_a === void 0 ? {} : _a).connectionTimeoutMs,\n                      connectionTimeoutMs = _b === void 0 ? DEFAULT_KEEP_ALIVE_TIMEOUT : _b;\n\n                  if (type === MESSAGE_TYPES.GQL_CONNECTION_ACK) {\n                    ackOk = true;\n                    _this.keepAliveTimeout = connectionTimeoutMs;\n                    _this.awsRealTimeSocket.onmessage = _this._handleIncomingSubscriptionMessage.bind(_this);\n\n                    _this.awsRealTimeSocket.onerror = function (err) {\n                      logger.debug(err);\n\n                      _this._errorDisconnect(CONTROL_MSG.CONNECTION_CLOSED);\n                    };\n\n                    _this.awsRealTimeSocket.onclose = function (event) {\n                      logger.debug(\"WebSocket closed \" + event.reason);\n\n                      _this._errorDisconnect(CONTROL_MSG.CONNECTION_CLOSED);\n                    };\n\n                    res('Cool, connected to AWS AppSyncRealTime');\n                    return;\n                  }\n\n                  if (type === MESSAGE_TYPES.GQL_CONNECTION_ERROR) {\n                    var _c = data.payload,\n                        _d = (_c === void 0 ? {} : _c).errors,\n                        _e = __read(_d === void 0 ? [] : _d, 1),\n                        _f = _e[0],\n                        _g = _f === void 0 ? {} : _f,\n                        _h = _g.errorType,\n                        errorType = _h === void 0 ? '' : _h,\n                        _j = _g.errorCode,\n                        errorCode = _j === void 0 ? 0 : _j;\n\n                    rej({\n                      errorType: errorType,\n                      errorCode: errorCode\n                    });\n                  }\n                };\n\n                var gqlInit = {\n                  type: MESSAGE_TYPES.GQL_CONNECTION_INIT\n                };\n\n                _this.awsRealTimeSocket.send(JSON.stringify(gqlInit));\n\n                function checkAckOk() {\n                  if (!ackOk) {\n                    rej(new Error(\"Connection timeout: ack from AWSRealTime was not received on \" + CONNECTION_INIT_TIMEOUT + \" ms\"));\n                  }\n                }\n\n                setTimeout(checkAckOk.bind(_this), CONNECTION_INIT_TIMEOUT);\n              });\n            }()];\n\n          case 3:\n            // Step 2: wait for ack from AWS AppSyncReaTime after sending init\n            _b.sent();\n\n            return [3\n            /*break*/\n            , 5];\n\n          case 4:\n            err_4 = _b.sent();\n            errorType = err_4.errorType, errorCode = err_4.errorCode;\n\n            if (NON_RETRYABLE_CODES.includes(errorCode)) {\n              throw new NonRetryableError(errorType);\n            } else if (errorType) {\n              throw new Error(errorType);\n            } else {\n              throw err_4;\n            }\n\n            return [3\n            /*break*/\n            , 5];\n\n          case 5:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  AWSAppSyncRealTimeProvider.prototype._awsRealTimeHeaderBasedAuth = function (_a) {\n    var authenticationType = _a.authenticationType,\n        payload = _a.payload,\n        canonicalUri = _a.canonicalUri,\n        appSyncGraphqlEndpoint = _a.appSyncGraphqlEndpoint,\n        apiKey = _a.apiKey,\n        region = _a.region,\n        additionalHeaders = _a.additionalHeaders;\n    return __awaiter(this, void 0, void 0, function () {\n      var headerHandler, handler, host, result;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            headerHandler = {\n              API_KEY: this._awsRealTimeApiKeyHeader.bind(this),\n              AWS_IAM: this._awsRealTimeIAMHeader.bind(this),\n              OPENID_CONNECT: this._awsRealTimeOPENIDHeader.bind(this),\n              AMAZON_COGNITO_USER_POOLS: this._awsRealTimeCUPHeader.bind(this),\n              AWS_LAMBDA: this._customAuthHeader\n            };\n            handler = headerHandler[authenticationType];\n\n            if (typeof handler !== 'function') {\n              logger.debug(\"Authentication type \" + authenticationType + \" not supported\");\n              return [2\n              /*return*/\n              , ''];\n            }\n\n            host = url.parse(appSyncGraphqlEndpoint).host;\n            return [4\n            /*yield*/\n            , handler({\n              payload: payload,\n              canonicalUri: canonicalUri,\n              appSyncGraphqlEndpoint: appSyncGraphqlEndpoint,\n              apiKey: apiKey,\n              region: region,\n              host: host,\n              additionalHeaders: additionalHeaders\n            })];\n\n          case 1:\n            result = _b.sent();\n            return [2\n            /*return*/\n            , result];\n        }\n      });\n    });\n  };\n\n  AWSAppSyncRealTimeProvider.prototype._awsRealTimeCUPHeader = function (_a) {\n    var host = _a.host;\n    return __awaiter(this, void 0, void 0, function () {\n      var session;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , Auth.currentSession()];\n\n          case 1:\n            session = _b.sent();\n            return [2\n            /*return*/\n            , {\n              Authorization: session.getAccessToken().getJwtToken(),\n              host: host\n            }];\n        }\n      });\n    });\n  };\n\n  AWSAppSyncRealTimeProvider.prototype._awsRealTimeOPENIDHeader = function (_a) {\n    var host = _a.host;\n    return __awaiter(this, void 0, void 0, function () {\n      var token, federatedInfo, currentUser;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , Cache.getItem('federatedInfo')];\n\n          case 1:\n            federatedInfo = _b.sent();\n            if (!federatedInfo) return [3\n            /*break*/\n            , 2];\n            token = federatedInfo.token;\n            return [3\n            /*break*/\n            , 4];\n\n          case 2:\n            return [4\n            /*yield*/\n            , Auth.currentAuthenticatedUser()];\n\n          case 3:\n            currentUser = _b.sent();\n\n            if (currentUser) {\n              token = currentUser.token;\n            }\n\n            _b.label = 4;\n\n          case 4:\n            if (!token) {\n              throw new Error('No federated jwt');\n            }\n\n            return [2\n            /*return*/\n            , {\n              Authorization: token,\n              host: host\n            }];\n        }\n      });\n    });\n  };\n\n  AWSAppSyncRealTimeProvider.prototype._awsRealTimeApiKeyHeader = function (_a) {\n    var apiKey = _a.apiKey,\n        host = _a.host;\n    return __awaiter(this, void 0, void 0, function () {\n      var dt, dtStr;\n      return __generator(this, function (_b) {\n        dt = new Date();\n        dtStr = dt.toISOString().replace(/[:\\-]|\\.\\d{3}/g, '');\n        return [2\n        /*return*/\n        , {\n          host: host,\n          'x-amz-date': dtStr,\n          'x-api-key': apiKey\n        }];\n      });\n    });\n  };\n\n  AWSAppSyncRealTimeProvider.prototype._awsRealTimeIAMHeader = function (_a) {\n    var payload = _a.payload,\n        canonicalUri = _a.canonicalUri,\n        appSyncGraphqlEndpoint = _a.appSyncGraphqlEndpoint,\n        region = _a.region;\n    return __awaiter(this, void 0, void 0, function () {\n      var endpointInfo, credentialsOK, creds, request, signed_params;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            endpointInfo = {\n              region: region,\n              service: 'appsync'\n            };\n            return [4\n            /*yield*/\n            , this._ensureCredentials()];\n\n          case 1:\n            credentialsOK = _b.sent();\n\n            if (!credentialsOK) {\n              throw new Error('No credentials');\n            }\n\n            return [4\n            /*yield*/\n            , Credentials.get().then(function (credentials) {\n              return {\n                secret_key: credentials.secretAccessKey,\n                access_key: credentials.accessKeyId,\n                session_token: credentials.sessionToken\n              };\n            })];\n\n          case 2:\n            creds = _b.sent();\n            request = {\n              url: \"\" + appSyncGraphqlEndpoint + canonicalUri,\n              data: payload,\n              method: 'POST',\n              headers: __assign({}, AWS_APPSYNC_REALTIME_HEADERS)\n            };\n            signed_params = Signer.sign(request, creds, endpointInfo);\n            return [2\n            /*return*/\n            , signed_params.headers];\n        }\n      });\n    });\n  };\n\n  AWSAppSyncRealTimeProvider.prototype._customAuthHeader = function (_a) {\n    var host = _a.host,\n        additionalHeaders = _a.additionalHeaders;\n\n    if (!additionalHeaders.Authorization) {\n      throw new Error('No auth token specified');\n    }\n\n    return {\n      Authorization: additionalHeaders.Authorization,\n      host: host\n    };\n  };\n  /**\n   * @private\n   */\n\n\n  AWSAppSyncRealTimeProvider.prototype._ensureCredentials = function () {\n    return Credentials.get().then(function (credentials) {\n      if (!credentials) return false;\n      var cred = Credentials.shear(credentials);\n      logger.debug('set credentials for AWSAppSyncRealTimeProvider', cred);\n      return true;\n    }).catch(function (err) {\n      logger.warn('ensure credentials error', err);\n      return false;\n    });\n  };\n\n  return AWSAppSyncRealTimeProvider;\n}(AbstractPubSubProvider);\n\nexport { AWSAppSyncRealTimeProvider };","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;AAYA,OAAOA,UAAP,MAA0C,mBAA1C;AACA,SAASC,YAAT,QAA6B,SAA7B;AACA,OAAO,KAAKC,GAAZ,MAAqB,KAArB;AACA,SAASC,EAAE,IAAIC,IAAf,QAA2B,MAA3B;AACA,SAASC,MAAT,QAAuB,QAAvB;AAEA,SACCC,MADD,EAECC,WAFD,EAGCC,MAHD,EAICC,GAJD,EAKCC,SALD,EAMCC,iBAND,EAOCC,wBAPD,EAQCC,iBARD,QASO,mBATP;AAUA,OAAOC,KAAP,MAAkB,oBAAlB;AACA,OAAOC,IAAP,MAAiB,mBAAjB;AACA,SAASC,sBAAT,QAAuC,kBAAvC;AACA,SAASC,WAAT,QAA4B,UAA5B;AAEA,IAAMC,MAAM,GAAG,IAAIZ,MAAJ,CAAW,4BAAX,CAAf;AAEA,IAAMa,cAAc,GAAI,OAAOC,MAAP,KAAkB,WAAlB,IACxB,OAAOA,MAAM,CAACC,GAAd,KAAsB,UADE,GAErBD,MAAM,CAACC,GAAP,CAAW,iBAAX,CAFqB,GAGrB,mBAHH;;AAKA,IAAMC,gBAAgB,GAAG,UAACC,KAAD,EAAgBC,IAAhB,EAA2BC,OAA3B,EAA0C;AAClEhB,KAAG,CAACiB,QAAJ,CAAa,KAAb,EAAoB;AAAEH,SAAK,OAAP;AAASC,QAAI,MAAb;AAAeC,WAAO;AAAtB,GAApB,EAA8C,QAA9C,EAAwDN,cAAxD;AACA,CAFD;;AAIA,IAAMQ,YAAY,GAAG,IAArB;AAEA,IAAMC,mBAAmB,GAAG,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,CAA5B;AAYA,IAAKC,aAAL;;AAAA,WAAKA,aAAL,EAAkB;AACjB;;;;AAIAA;AACA;;;;;AAIAA;AACA;;;;;AAIAA;AACA;;;;;AAIAA;AACA;;;;;AAIAA;AACA;;;;;AAIAA;AACA;;;;;AAIAA;AACA;;;;;AAIAA;AACA;;;;;AAIAA;AACA;;;;;AAIAA;AACA,CAnDD,EAAKA,aAAa,KAAbA,aAAa,MAAlB;;AAqDA,IAAKC,mBAAL;;AAAA,WAAKA,mBAAL,EAAwB;AACvBA;AACAA;AACAA;AACA,CAJD,EAAKA,mBAAmB,KAAnBA,mBAAmB,MAAxB;;AAMA,IAAKC,aAAL;;AAAA,WAAKA,aAAL,EAAkB;AACjBA;AACAA;AACAA;AACA,CAJD,EAAKA,aAAa,KAAbA,aAAa,MAAlB;;AAMA,IAAMC,4BAA4B,GAAG;AACpCC,QAAM,EAAE,mCAD4B;AAEpC,sBAAoB,SAFgB;AAGpC,kBAAgB;AAHoB,CAArC;AAMA;;;;AAGA,IAAMC,uBAAuB,GAAG,KAAhC;AAEA;;;;AAGA,IAAMC,iBAAiB,GAAG,KAA1B;AAEA;;;;AAGA,IAAMC,0BAA0B,GAAG,IAAI,EAAJ,GAAS,IAA5C;AAEA,IAAMC,qBAAqB,GAAG,uFAA9B;AAEA,IAAMC,gBAAgB,GAAG,WAAzB;;AAEA;AAAA;AAAA;AAAgDC;;AAAhD;AAAA;;AAESC,yBAA8BT,aAAa,CAACU,MAA5C;AAEAD,6BAAmBJ,0BAAnB;AACAI,oCAAsD,IAAIE,GAAJ,EAAtD;AACAF,yBAAwD,EAAxD;;AAuvBR;;AArvBAG;AACC,WAAO,4BAAP;AACA,GAFD;;AAIAA;AACC,UAAM,IAAIC,KAAJ,CAAU,eAAV,CAAN;AACA,GAFD;;AAIaD,iDAAb,UAAqBE,OAArB,EAAiDC,IAAjD,EAA4DC,QAA5D,EAA0E;;;AACzE,cAAM,IAAIH,KAAJ,CAAU,yBAAV,CAAN;;;AACA,GAFY,CAhBd,CAoBC;;;AACQD,wDAAR,UAAuBzC,GAAvB,EAAkC;AACjC,WAAOA,GAAG,CAAC8C,KAAJ,CAAUX,qBAAV,MAAqC,IAA5C;AACA,GAFO;;AAIRM,6DACCE,OADD,EAECI,OAFD,EAE2B;AAF3B;;AAIS;AAER,WAAO,IAAIjD,UAAJ,CAAe,oBAAQ;AAC7B,UAAI,CAACkD,sBAAL,EAA6B;AAC5BC,gBAAQ,CAACC,KAAT,CAAe;AACdC,gBAAM,EAAE,cAEH,IAAIpD,YAAJ,CACF,mDADE,EAFG;AADM,SAAf;AASAkD,gBAAQ,CAACG,QAAT;AACA,OAXD,MAWO;AACN,YAAMC,gBAAc,GAAGnD,IAAI,EAA3B;;AACAoC,aAAI,CAACgB,wCAAL,CAA8C;AAC7CP,iBAAO,SADsC;AAE7CE,kBAAQ,UAFqC;AAG7CM,wBAAc;AAH+B,SAA9C,EAIGC,KAJH,CAIS,eAAG;AACXP,kBAAQ,CAACC,KAAT,CAAe;AACdC,kBAAM,EAAE,cAEH,IAAIpD,YAAJ,CACCgB,WAAW,CAAC0C,gCAAZ,GAA4C,IAA5C,GAAiDC,GADlD,EAFG;AADM,WAAf;AASAT,kBAAQ,CAACG,QAAT;AACA,SAfD;;AAiBA,eAAO;AAAA;;;;;8CAGL;;;AACA;AAAA;AAAA,oBAAM,KAAKO,iCAAL,CAAuCN,gBAAvC,CAAN;;;AADA;AACAO;;AAEQC,mCAAiB,GACxB,MAAKC,uBAAL,CAA6BC,GAA7B,CAAiCV,gBAAjC,KAAoD,EAApD,EAAsDQ,iBAD/C;;AAGR,sBAAI,CAACA,iBAAL,EAAwB;AACvB;AACA;AAAA;AAAA;AACA;;AAED,sBAAIA,iBAAiB,KAAKjC,mBAAmB,CAACoC,SAA9C,EAAyD;AACxD,yBAAKC,0BAAL,CAAgCZ,gBAAhC;AACA,mBAFD,MAEO;AACN,0BAAM,IAAIX,KAAJ,CAAU,8BAAV,CAAN;AACA;;;;;;;;AAED1B,wBAAM,CAACkD,KAAP,CAAa,+BAA6BC,KAA1C;;;;;;AAEA,uBAAKC,2BAAL,CAAiCf,gBAAjC;;;;;;;;;;;;WAtBK;AAwBN,SAxBD;AAyBA;AACD,KAzDM,CAAP;AA0DA,GAhED;;AAkEAgB,wBAAc5B,oCAAd,EAAc,cAAd,EAA0B;SAA1B;AACC,aAAO,CAAC,KAAKM,OAAL,CACNuB,4DADF;AAEA,KAHyB;oBAAA;;AAAA,GAA1B;;AAIc7B,kFAAd,UAAuDmB,EAAvD,EAIC;QAHAb;QACAE;QACAM;;;;;;;;;;;AAGCP,kCAAsB,GAQnBD,OAAO,uBARV,EACAwB,kBAAkB,GAOfxB,OAAO,mBARV,EAEAyB,KAAK,GAMFzB,OAAO,MARV,EAGA0B,SAAS,GAKN1B,OAAO,UARV,EAIA2B,MAAM,GAIH3B,OAAO,OARV,EAKA4B,MAAM,GAGH5B,OAAO,OARV,EAMA6B,KAEG7B,OAAO,gBARV,EAMA8B,eAAe,mBAAG;AAAM,qBAAC,EAAD;AAAI,aAAb,GAAaD,EAN5B,EAOAE,KACG/B,OAAO,kBARV,EAOAgC,iBAAiB,mBAAG,EAAH,GAAKD,EAPtB;AAUKjB,6BAAiB,GAAwBjC,mBAAmB,CAACoD,OAA7D;AACA1D,gBAAI,GAAG;AACZkD,mBAAK,OADO;AAEZC,uBAAS;AAFG,aAAP,EAIN;;AACA,iBAAKX,uBAAL,CAA6BmB,GAA7B,CAAiC1B,cAAjC,EAAiD;AAChDN,sBAAQ,UADwC;AAEhDuB,mBAAK,OAF2C;AAGhDC,uBAAS,WAHuC;AAIhDZ,+BAAiB,mBAJ+B;AAKhDqB,+BAAiB,EAAE;AAL6B,aAAjD;AAUMC,sBAAU,GAAGC,IAAI,CAACC,SAAL,CAAe/D,IAAf,CAAb;;AAED;AAAA;AAAA,cAAM,KAAKgE,2BAAL,CAAiC;AAC1CZ,oBAAM,QADoC;AAE1C1B,oCAAsB,wBAFoB;AAG1CuB,gCAAkB,oBAHwB;AAI1CgB,qBAAO,EAAEJ,UAJiC;AAK1CK,0BAAY,EAAE,EAL4B;AAM1Cb,oBAAM,QANoC;AAO1CI,+BAAiB;AAPyB,aAAjC,CAAN;;;oDAAAU;AASA;AAAA;AAAA,cAAMZ,eAAe,EAArB;;;AAVCa,qBAAS,qFAUVD,SAVU,KAWXV,iBAXW,KAWMY,YACnBlF,iBADmB,IACCD,SAAS,CAACoF,SADX,EACoBD,EAZ1B,GAAT;AAeAE,+BAAmB,GAAG;AAC3BC,gBAAE,EAAEvC,cADuB;AAE3BgC,qBAAO,EAAE;AACRjE,oBAAI,EAAE6D,UADE;AAERY,0BAAU,EAAE;AACXC,+BAAa,eACTN,SADS;AADF;AAFJ,eAFkB;AAU3BO,kBAAI,EAAEtE,aAAa,CAACuE;AAVO,aAAtB;AAaAC,+BAAmB,GAAGf,IAAI,CAACC,SAAL,CAAeQ,mBAAf,CAAtB;;;;;;AAGL;AAAA;AAAA,cAAM,KAAKO,8BAAL,CAAoC;AACzC1B,oBAAM,QADmC;AAEzC1B,oCAAsB,wBAFmB;AAGzCuB,gCAAkB,oBAHuB;AAIzCI,oBAAM,QAJmC;AAKzCI,+BAAiB;AALwB,aAApC,CAAN;;;AAAAU;;;;;;;;AAQAzE,kBAAM,CAACkD,KAAP,CAAa;AAAER,iBAAG;AAAL,aAAb;AACQ2C,iBAAiBC,KAAG,QAApB,SAAO,mBAAG,EAAH,GAAKD,EAAZ;AACRpD,oBAAQ,CAACC,KAAT,CAAe;AACdC,oBAAM,EAAE,cAEH,IAAIpD,YAAJ,CAAoBgB,WAAW,CAACwF,iBAAZ,GAA6B,IAA7B,GAAkChF,OAAtD,EAFG;AADM,aAAf;AAOA0B,oBAAQ,CAACG,QAAT;AAEQoD,2CACP,MAAK1C,uBAAL,CAA6BC,GAA7B,CAAiCR,cAAjC,KAAoD,EAApD,EAAsDkD,0BAD/C,EAGR;;AACA,gBAAI,OAAOD,4BAAP,KAAsC,UAA1C,EAAsD;AACrDA,0CAA0B;AAC1B;;AACD;AAAA;AAAA;;;AAOKE,iBAGF,KAAK5C,uBAAL,CAA6BC,GAA7B,CAAiCR,cAAjC,CAHE,EACLkD,0BAA0B,gCADrB,EAELE,yBAAyB,+BAFpB,EAKN;;AACA,iBAAK7C,uBAAL,CAA6BmB,GAA7B,CAAiC1B,cAAjC,EAAiD;AAChDN,sBAAQ,UADwC;AAEhDY,+BAAiB,mBAF+B;AAGhDY,uBAAS,WAHuC;AAIhDD,mBAAK,OAJ2C;AAKhDmC,uCAAyB,2BALuB;AAMhDF,wCAA0B,4BANsB;AAOhDvB,+BAAiB,EAAE0B,UAAU,CAAC;AAC7BtE,qBAAI,CAACuE,4BAAL,CAAkCC,IAAlC,CAAuCxE,KAAvC,EAA6CiB,cAA7C;AACA,eAF4B,EAE1BtB,iBAF0B;AAPmB,aAAjD;;AAWA,gBAAI,KAAK8E,iBAAT,EAA4B;AAC3B,mBAAKA,iBAAL,CAAuBC,IAAvB,CAA4Bb,mBAA5B;AACA;;;;;;;;AACD,GArHa,CA/Ff,CAsNC;;;AACc1D,2EAAd,UAAgDc,cAAhD,EAA8D;;;;;;;AACrDM,yBAAiB,GAAK,KAAKC,uBAAL,CAA6BC,GAA7B,CAC7BR,cAD6B,EAE7BM,iBAFO,EAGR;;AACA,YAAIA,iBAAiB,KAAKjC,mBAAmB,CAACoD,OAA9C,EAAuD;AACtD;AAAA;AAAA,YAAO,IAAIiC,OAAJ,CAAY,UAACC,GAAD,EAAMC,GAAN,EAAS;AACrB;AAAA,gBACLlE,sBADK;AAAA,gBAELY,wCAFK;AAAA,gBAGLY,wBAHK;AAAA,gBAILD,gBAJK;;AAMNlC,iBAAI,CAACwB,uBAAL,CAA6BmB,GAA7B,CAAiC1B,cAAjC,EAAiD;AAChDN,sBAAQ,UADwC;AAEhDY,+BAAiB,mBAF+B;AAGhDY,uBAAS,WAHuC;AAIhDD,mBAAK,OAJ2C;AAKhDmC,uCAAyB,EAAEO,GALqB;AAMhDT,wCAA0B,EAAEU;AANoB,aAAjD;AAQA,WAfM,CAAP;AAgBA;;;;;;;AACD,GAvBa;;AAyBN1E,oEAAR,UAAmCc,cAAnC,EAAiD;AAChD,QAAI;AACH,UACC,KAAKwD,iBAAL,IACA,KAAKA,iBAAL,CAAuBK,UAAvB,KAAsCC,SAAS,CAACC,IADhD,IAEA,KAAKC,YAAL,KAAsB1F,aAAa,CAAC2F,KAHrC,EAIE;AACD;AACA,YAAMC,kBAAkB,GAAG;AAC1B3B,YAAE,EAAEvC,cADsB;AAE1B0C,cAAI,EAAEtE,aAAa,CAAC+F;AAFM,SAA3B;AAIA,YAAMvB,mBAAmB,GAAGf,IAAI,CAACC,SAAL,CAAeoC,kBAAf,CAA5B;AACA,aAAKV,iBAAL,CAAuBC,IAAvB,CAA4Bb,mBAA5B;AACA;AACD,KAdD,CAcE,OAAOzC,GAAP,EAAY;AACb;AACA1C,YAAM,CAACkD,KAAP,CAAa;AAAER,WAAG;AAAL,OAAb;AACA;AACD,GAnBO;;AAqBAjB,qEAAR,UAAoCc,cAApC,EAAkD;AACjD,SAAKO,uBAAL,CAA6B6D,MAA7B,CAAoCpE,cAApC,EADiD,CAGjD;;AACAqD,cAAU,CAAC,KAAKgB,sBAAL,CAA4BC,IAA5B,CAAiC,IAAjC,CAAD,EAAyC,IAAzC,CAAV;AACA,GALO;;AAOApF,gEAAR;AACC,QAAI,KAAKqB,uBAAL,CAA6BgE,IAA7B,GAAoC,CAAxC,EAA2C;AAC1C;AACA;AACA;;AAED,QAAI,CAAC,KAAKf,iBAAV,EAA6B;AAC5B,WAAKQ,YAAL,GAAoB1F,aAAa,CAACU,MAAlC;AACA;AACA;;AACD,QAAI,KAAKwE,iBAAL,CAAuBgB,cAAvB,GAAwC,CAA5C,EAA+C;AAC9C;AACAnB,gBAAU,CAAC,KAAKgB,sBAAL,CAA4BC,IAA5B,CAAiC,IAAjC,CAAD,EAAyC,IAAzC,CAAV;AACA,KAHD,MAGO;AACN7G,YAAM,CAACkD,KAAP,CAAa,sBAAb;AACA8D,kBAAY,CAAC,KAAKC,kBAAN,CAAZ;AACA,UAAMC,UAAU,GAAG,KAAKnB,iBAAxB,CAHM,CAIN;;AACAmB,gBAAU,CAACC,OAAX,GAAqBC,SAArB;AACAF,gBAAU,CAACG,OAAX,GAAqBD,SAArB;AACAF,gBAAU,CAACI,KAAX,CAAiB,IAAjB;AACA,WAAKvB,iBAAL,GAAyB,IAAzB;AACA,WAAKQ,YAAL,GAAoB1F,aAAa,CAACU,MAAlC;AACA;AACD,GAxBO;;AA0BAE,4EAAR,UAA2ClB,OAA3C,EAAgE;AAC/DP,UAAM,CAACkD,KAAP,CACC,qDAAmD3C,OAAO,CAACD,IAD5D;;AAGM;AAAA,QAAEsD,UAAF;AAAA,QAAEkB,4BAAF;AAAA,QAAWP,oBAAX;AAAA,QAAoBU,cAApB;;AACA;AAAA,QACLsC,gBADK;AAAA,QACLtF,oCADK;AAAA,QAELuF,aAFK;AAAA,QAELhE,+BAFK;AAAA,QAGL6B,iBAHK;AAAA,QAGL5B,mCAHK;AAAA,QAILS,wCAJK;AAAA,QAKLyB,wDALK;AAAA,QAMLF,0DANK;;AASNzF,UAAM,CAACkD,KAAP,CAAa;AAAE4B,QAAE,IAAJ;AAAM7C,cAAQ,UAAd;AAAgBuB,WAAK,OAArB;AAAuBC,eAAS;AAAhC,KAAb;;AAEA,QAAIwB,IAAI,KAAKtE,aAAa,CAAC8G,QAAvB,IAAmClD,OAAnC,IAA8CA,OAAO,CAACjE,IAA1D,EAAgE;AAC/D,UAAI2B,QAAJ,EAAc;AACbA,gBAAQ,CAACyF,IAAT,CAAcnD,OAAd;AACA,OAFD,MAEO;AACNvE,cAAM,CAACkD,KAAP,CAAa,gCAA8B4B,EAA3C;AACA;;AACD;AACA;;AAED,QAAIG,IAAI,KAAKtE,aAAa,CAACgH,aAA3B,EAA0C;AACzC3H,YAAM,CAACkD,KAAP,CACC,4BAA0BkB,IAAI,CAACC,SAAL,CAAe;AAAEb,aAAK,OAAP;AAASC,iBAAS;AAAlB,OAAf,CAD3B;;AAGA,UAAI,OAAOkC,yBAAP,KAAqC,UAAzC,EAAqD;AACpDA,iCAAyB;AACzB;;AACDqB,kBAAY,CAAC9C,iBAAD,CAAZ;AACA9D,sBAAgB,CACfL,WAAW,CAAC6H,gBADG,EAEf;AAAEpE,aAAK,OAAP;AAASC,iBAAS;AAAlB,OAFe,EAGf,yCAHe,CAAhB;AAKA,UAAMZ,iBAAiB,GAAGjC,mBAAmB,CAACoC,SAA9C;AACA,WAAKF,uBAAL,CAA6BmB,GAA7B,CAAiCa,EAAjC,EAAqC;AACpC7C,gBAAQ,UAD4B;AAEpCuB,aAAK,OAF+B;AAGpCC,iBAAS,WAH2B;AAIpCS,yBAAiB,EAAE,IAJiB;AAKpCrB,yBAAiB,mBALmB;AAMpC8C,iCAAyB,2BANW;AAOpCF,kCAA0B;AAPU,OAArC,EAdyC,CAwBzC;;AACA;AACA;;AAED,QAAIR,IAAI,KAAKtE,aAAa,CAACkH,yBAA3B,EAAsD;AACrDb,kBAAY,CAAC,KAAKC,kBAAN,CAAZ;AACA,WAAKA,kBAAL,GAA0BrB,UAAU,CACnC,KAAKkC,gBAAL,CAAsBjB,IAAtB,CAA2B,IAA3B,EAAiC9G,WAAW,CAACgI,kBAA7C,CADmC,EAEnC,KAAKC,gBAF8B,CAApC;AAIA;AACA;;AAED,QAAI/C,IAAI,KAAKtE,aAAa,CAACsH,SAA3B,EAAsC;AACrC,UAAMpF,iBAAiB,GAAGjC,mBAAmB,CAACsH,MAA9C;AACA,WAAKpF,uBAAL,CAA6BmB,GAA7B,CAAiCa,EAAjC,EAAqC;AACpC7C,gBAAQ,UAD4B;AAEpCuB,aAAK,OAF+B;AAGpCC,iBAAS,WAH2B;AAIpCS,yBAAiB,mBAJmB;AAKpCyB,iCAAyB,2BALW;AAMpCF,kCAA0B,4BANU;AAOpC5C,yBAAiB;AAPmB,OAArC;AAUAZ,cAAQ,CAACC,KAAT,CAAe;AACdC,cAAM,EAAE,cAEH,IAAIpD,YAAJ,CACCgB,WAAW,CAACwF,iBAAZ,GAA6B,IAA7B,GAAkCnB,IAAI,CAACC,SAAL,CAAeE,OAAf,CADnC,EAFG;AADM,OAAf;AASAyC,kBAAY,CAAC9C,iBAAD,CAAZ;AAEAjC,cAAQ,CAACG,QAAT;;AACA,UAAI,OAAOqD,0BAAP,KAAsC,UAA1C,EAAsD;AACrDA,kCAA0B;AAC1B;AACD;AACD,GA1FO;;AA4FAhE,0DAAR,UAAyB0G,GAAzB,EAAoC;AACnCnI,UAAM,CAACkD,KAAP,CAAa,uBAAqBiF,GAAlC;AACA,SAAKrF,uBAAL,CAA6BsF,OAA7B,CAAqC,UAACxF,EAAD,EAAa;UAAVX;;AACvC,UAAIA,QAAQ,IAAI,CAACA,QAAQ,CAACoG,MAA1B,EAAkC;AACjCpG,gBAAQ,CAACC,KAAT,CAAe;AACdC,gBAAM,EAAE,cAAM,IAAIpD,YAAJ,CAAiBoJ,GAAjB,CAAN;AADM,SAAf;AAGA;AACD,KAND;AAOA,SAAKrF,uBAAL,CAA6BwF,KAA7B;;AACA,QAAI,KAAKvC,iBAAT,EAA4B;AAC3B,WAAKA,iBAAL,CAAuBuB,KAAvB;AACA;;AAED,SAAKf,YAAL,GAAoB1F,aAAa,CAACU,MAAlC;AACA,GAfO;;AAiBAE,sEAAR,UAAqCc,cAArC,EAAmD;AAC5C;AAAA,QAAEN,sBAAF;AAAA,QAAYuB,gBAAZ;AAAA,QAAmBC,wBAAnB;;AAEN,QAAI,CAACxB,QAAL,EAAe;AACd;AACA;;AACD,SAAKa,uBAAL,CAA6BmB,GAA7B,CAAiC1B,cAAjC,EAAiD;AAChDN,cAAQ,UADwC;AAEhDuB,WAAK,OAF2C;AAGhDC,eAAS,WAHuC;AAIhDZ,uBAAiB,EAAEjC,mBAAmB,CAACsH;AAJS,KAAjD;;AAOA,QAAIjG,QAAQ,IAAI,CAACA,QAAQ,CAACoG,MAA1B,EAAkC;AACjCpG,cAAQ,CAACC,KAAT,CAAe;AACdC,cAAM,EAAE,cAEH,IAAIpD,YAAJ,CACF,0BAAwBqF,IAAI,CAACC,SAAL,CAAe;AACtCb,eAAK,OADiC;AAEtCC,mBAAS;AAF6B,SAAf,CADtB,EAFG;AADM,OAAf,EADiC,CAajC;;AACAxB,cAAQ,CAACG,QAAT;AACA;;AACDpC,UAAM,CAACkD,KAAP,CACC,0BADD,EAECkB,IAAI,CAACC,SAAL,CAAe;AAAEb,WAAK,OAAP;AAASC,eAAS;AAAlB,KAAf,CAFD;AAIA,GAjCO;;AAmCAhC,wEAAR,UAAuCmB,EAAvC,EAMC;AAND;;QACCZ;QACAuB;QACAG;QACAC;QACAI;;AAEA,QAAI,KAAKwC,YAAL,KAAsB1F,aAAa,CAAC2F,KAAxC,EAA+C;AAC9C;AACA;;AACD,WAAO,IAAIP,OAAJ,CAAY,UAAOC,GAAP,EAAYC,GAAZ,EAAe;AAAA;;;;;;AACjC,mBAAKoC,YAAL,CAAkBC,IAAlB,CAAuB;AAAEtC,mBAAG,KAAL;AAAOC,mBAAG;AAAV,eAAvB;oBAEI,KAAKI,YAAL,KAAsB1F,aAAa,CAACU,SAApC;AAAA;AAAA;;;;;;AAEF,mBAAKgF,YAAL,GAAoB1F,aAAa,CAAC4H,UAAlC;AAEMC,2BAAa,GAAG,IAAhB;AACe9E,+BAAKS,SAAL;AACpB;AAAA;AAAA,gBAAM,KAAKC,2BAAL,CAAiC;AACtCf,kCAAkB,oBADoB;AAEtCgB,uBAAO,EAAEmE,aAF6B;AAGtClE,4BAAY,EAAE,UAHwB;AAItCd,sBAAM,QAJgC;AAKtC1B,sCAAsB,wBALgB;AAMtC2B,sBAAM,QANgC;AAOtCI,iCAAiB;AAPqB,eAAjC,CAAN;;;AADK4E,0BAAY,GAAG/E,cACpBE,SADoB,EAAf;AAWA8E,sBAAQ,GAAGzJ,MAAM,CAAC0J,IAAP,CAAYF,YAAZ,EAA0BG,QAA1B,CAAmC,QAAnC,CAAX;AAEAC,uBAAS,GAAG5J,MAAM,CAAC0J,IAAP,CAAYH,aAAZ,EAA2BI,QAA3B,CAAoC,QAApC,CAAZ;AAEFE,kCAAoB,GAAGhH,sBAAvB;;AAEJ,kBAAI,KAAKiH,cAAL,CAAoBD,oBAApB,CAAJ,EAA+C;AAC9CA,oCAAoB,GAAGA,oBAAoB,CAACE,MAArB,CACtB9H,gBADsB,CAAvB;AAGA,eAJD,MAIO;AACN4H,oCAAoB,GAAGA,oBAAoB,CAACG,OAArB,CAA6B,aAA7B,EAA4C,sBAA5C,EAAoEA,OAApE,CAA4E,WAA5E,EAAyF,UAAzF,CAAvB;AACA;;AAGKC,sBAAQ,GAAG,KAAKC,YAAL,GAAoB,QAApB,GAA+B,OAA1C;AACNL,kCAAoB,GAAGA,oBAAoB,CACzCG,OADqB,CACb,UADa,EACDC,QADC,EAErBD,OAFqB,CAEb,SAFa,EAEFC,QAFE,CAAvB;AAIME,4BAAc,GAAMN,oBAAoB,aAApB,GAA+BJ,QAA/B,GAAuC,WAAvC,GAAmDG,SAAvE;AAEN;AAAA;AAAA,gBAAM,KAAKQ,6BAAL,CAAmC;AAAED,8BAAc;AAAhB,eAAnC,CAAN;;;AAAAxF;;AAEA,mBAAKyE,YAAL,CAAkBH,OAAlB,CAA0B,UAACxF,EAAD,EAAQ;oBAALsD;AAC5BlG,sBAAM,CAACkD,KAAP,CAAa,iCAAb;AACAgD,mBAAG;AACH,eAHD;AAIA,mBAAKK,YAAL,GAAoB1F,aAAa,CAAC2F,KAAlC;AACA,mBAAK+B,YAAL,GAAoB,EAApB;;;;;;;AAEA,mBAAKA,YAAL,CAAkBH,OAAlB,CAA0B,UAACxF,EAAD,EAAQ;oBAALuD;AAAU,0BAAG,CAACqD,KAAD,CAAH;AAAQ,eAA/C;AACA,mBAAKjB,YAAL,GAAoB,EAApB;;AACA,kBACC,KAAKxC,iBAAL,IACA,KAAKA,iBAAL,CAAuBK,UAAvB,KAAsCC,SAAS,CAACC,IAFjD,EAGE;AACD,qBAAKP,iBAAL,CAAuBuB,KAAvB,CAA6B,IAA7B;AACA;;AACD,mBAAKvB,iBAAL,GAAyB,IAAzB;AACA,mBAAKQ,YAAL,GAAoB1F,aAAa,CAACU,MAAlC;;;;;;;;;;;OA3D+B;AA8DjC,KA9DM,CAAP;AA+DA,GAzEO;;AA2EME,uEAAd,UAA4CmB,EAA5C,EAA8D;QAAhB0G;;;;;AAC7CtJ,kBAAM,CAACkD,KAAP,CAAa,oCAAb;AACA;AAAA;AAAA,cAAMxD,wBAAwB,CAC7B,KAAK+J,oBAAL,CAA0B5C,IAA1B,CAA+B,IAA/B,CAD6B,EAE7B,CAAC;AAAEyC,4BAAc;AAAhB,aAAD,CAF6B,EAG7B7I,YAH6B,CAA9B;;;AAAAmD;;;;;;;;AAKA,GAPa;;AASAnC,8DAAd,UAAmCmB,EAAnC,EAAqD;QAAhB0G;;;;;;;;;AACpCtJ,kBAAM,CAACkD,KAAP,CAAa,4BAA0BoG,cAAvC;;;;;;AAIC;AAAA;AAAA,cAAO;AACN,qBAAO,IAAIrD,OAAJ,CAAkB,UAACC,GAAD,EAAMC,GAAN,EAAS;AACjC,oBAAMuD,SAAS,GAAG,IAAIrD,SAAJ,CAAciD,cAAd,EAA8B,YAA9B,CAAlB;;AACAI,yBAAS,CAACrC,OAAV,GAAoB;AACnBrH,wBAAM,CAACkD,KAAP,CAAa,4BAAb;AACA,iBAFD;;AAGAwG,yBAAS,CAACvC,OAAV,GAAoB;AACnBhB,qBAAG,CAAC,IAAIzE,KAAJ,CAAU,4BAAV,CAAD,CAAH;AACA,iBAFD;;AAGAgI,yBAAS,CAACC,MAAV,GAAmB;AAClBrI,uBAAI,CAACyE,iBAAL,GAAyB2D,SAAzB;AACA,yBAAOxD,GAAG,EAAV;AACA,iBAHD;AAIA,eAZM,CAAP;AAaA,aAdK,EAAN;;;AAAAtC,uBAgBA;;;AACA;AAAA;AAAA,cAAO;AACN,qBAAO,IAAIqC,OAAJ,CAAY,UAACC,GAAD,EAAMC,GAAN,EAAS;AAC3B,oBAAIyD,KAAK,GAAG,KAAZ;;AACAtI,qBAAI,CAACyE,iBAAL,CAAuBsB,OAAvB,GAAiC,iBAAK;AACrCrH,wBAAM,CAACkD,KAAP,CAAa,qBAAmBkB,IAAI,CAACC,SAAL,CAAenC,KAAf,CAAhC;AACA,iBAFD;;AAGAZ,qBAAI,CAACyE,iBAAL,CAAuBoB,OAAvB,GAAiC,iBAAK;AACrCnH,wBAAM,CAACkD,KAAP,CAAa,sBAAoB7C,KAAK,CAACwJ,MAAvC;AACA1D,qBAAG,CAAC,IAAIzE,KAAJ,CAAU0C,IAAI,CAACC,SAAL,CAAehE,KAAf,CAAV,CAAD,CAAH;AACA,iBAHD;;AAKAiB,qBAAI,CAACyE,iBAAL,CAAuB+D,SAAvB,GAAmC,UAACvJ,OAAD,EAAsB;AACxDP,wBAAM,CAACkD,KAAP,CACC,oDAAkD3C,OAAO,CAACD,IAA1D,GAA8D,GAD/D;AAGA,sBAAMA,IAAI,GAAG8D,IAAI,CAAC2F,KAAL,CAAWxJ,OAAO,CAACD,IAAnB,CAAb;AAEC;AAAA,sBACAsC,iBADA;AAAA,sBAECgB,kDAFD;AAAA,sBAECoG,qEAFD;;AAKD,sBAAI/E,IAAI,KAAKtE,aAAa,CAACsJ,kBAA3B,EAA+C;AAC9CL,yBAAK,GAAG,IAAR;AACAtI,yBAAI,CAAC0G,gBAAL,GAAwBgC,mBAAxB;AACA1I,yBAAI,CAACyE,iBAAL,CAAuB+D,SAAvB,GAAmCxI,KAAI,CAAC4I,kCAAL,CAAwCrD,IAAxC,CAClCvF,KADkC,CAAnC;;AAGAA,yBAAI,CAACyE,iBAAL,CAAuBsB,OAAvB,GAAiC,eAAG;AACnCrH,4BAAM,CAACkD,KAAP,CAAaR,GAAb;;AACApB,2BAAI,CAACwG,gBAAL,CAAsB/H,WAAW,CAACoK,iBAAlC;AACA,qBAHD;;AAIA7I,yBAAI,CAACyE,iBAAL,CAAuBoB,OAAvB,GAAiC,iBAAK;AACrCnH,4BAAM,CAACkD,KAAP,CAAa,sBAAoB7C,KAAK,CAACwJ,MAAvC;;AACAvI,2BAAI,CAACwG,gBAAL,CAAsB/H,WAAW,CAACoK,iBAAlC;AACA,qBAHD;;AAIAjE,uBAAG,CAAC,wCAAD,CAAH;AACA;AACA;;AAED,sBAAIjB,IAAI,KAAKtE,aAAa,CAACyJ,oBAA3B,EAAiD;AAE/C;AAAA,wBACC7C,qCADD;AAAA,wBACCC,uCADD;AAAA,wBACUnC,UADV;AAAA,wBACUK,4BADV;AAAA,wBACYf,iBADZ;AAAA,wBACY0F,mCADZ;AAAA,wBAC4B5F,iBAD5B;AAAA,wBAC4B6F,kCAD5B;;AAKDnE,uBAAG,CAAC;AAAEkE,+BAAS,WAAX;AAAaC,+BAAS;AAAtB,qBAAD,CAAH;AACA;AACD,iBAtCD;;AAwCA,oBAAMC,OAAO,GAAG;AACftF,sBAAI,EAAEtE,aAAa,CAAC6J;AADL,iBAAhB;;AAGAlJ,qBAAI,CAACyE,iBAAL,CAAuBC,IAAvB,CAA4B5B,IAAI,CAACC,SAAL,CAAekG,OAAf,CAA5B;;AAEA,yBAASE,UAAT,GAAmB;AAClB,sBAAI,CAACb,KAAL,EAAY;AACXzD,uBAAG,CACF,IAAIzE,KAAJ,CACC,kEAAgEV,uBAAhE,GAAuF,KADxF,CADE,CAAH;AAKA;AACD;;AAED4E,0BAAU,CAAC6E,UAAU,CAAC5D,IAAX,CAAgBvF,KAAhB,CAAD,EAAwBN,uBAAxB,CAAV;AACA,eAlEM,CAAP;AAmEA,aApEK,EAAN;;;AADA;AACA4C;;;;;;;;AAsEQyG,qBAAS,GAAgBK,KAAG,UAA5B,EAAWJ,SAAS,GAAKI,KAAG,UAA5B;;AAER,gBAAIhK,mBAAmB,CAACiK,QAApB,CAA6BL,SAA7B,CAAJ,EAA6C;AAC5C,oBAAM,IAAI3K,iBAAJ,CAAsB0K,SAAtB,CAAN;AACA,aAFD,MAEO,IAAIA,SAAJ,EAAe;AACrB,oBAAM,IAAI3I,KAAJ,CAAU2I,SAAV,CAAN;AACA,aAFM,MAEA;AACN,oBAAMK,KAAN;AACA;;;;;;;;;;;;;AAEF,GAtGa;;AAwGAjJ,qEAAd,UAA0CmB,EAA1C,EAQC;QAPAW;QACAgB;QACAC;QACAxC;QACA0B;QACAC;QACAI;;;;;;AAEM6G,yBAAa,GAAG;AACrBC,qBAAO,EAAE,KAAKC,wBAAL,CAA8BjE,IAA9B,CAAmC,IAAnC,CADY;AAErBkE,qBAAO,EAAE,KAAKC,qBAAL,CAA2BnE,IAA3B,CAAgC,IAAhC,CAFY;AAGrBoE,4BAAc,EAAE,KAAKC,wBAAL,CAA8BrE,IAA9B,CAAmC,IAAnC,CAHK;AAIrBsE,uCAAyB,EAAE,KAAKC,qBAAL,CAA2BvE,IAA3B,CAAgC,IAAhC,CAJN;AAKrBwE,wBAAU,EAAE,KAAKC;AALI,aAAhB;AAQAC,mBAAO,GAAGX,aAAa,CAACrH,kBAAD,CAAvB;;AAEN,gBAAI,OAAOgI,OAAP,KAAmB,UAAvB,EAAmC;AAClCvL,oBAAM,CAACkD,KAAP,CAAa,yBAAuBK,kBAAvB,GAAyC,gBAAtD;AACA;AAAA;AAAA,gBAAO,EAAP;AACA;;AAEOiI,gBAAI,GAAKxM,GAAG,CAAC+K,KAAJ,CAAU/H,sBAAV,EAAiCwJ,IAA1C;AAEO;AAAA;AAAA,cAAMD,OAAO,CAAC;AAC5BhH,qBAAO,SADqB;AAE5BC,0BAAY,cAFgB;AAG5BxC,oCAAsB,wBAHM;AAI5B0B,oBAAM,QAJsB;AAK5BC,oBAAM,QALsB;AAM5B6H,kBAAI,MANwB;AAO5BzH,+BAAiB;AAPW,aAAD,CAAb;;;AAAT0H,kBAAM,GAAG7H,SAAT;AAUN;AAAA;AAAA,cAAO6H,MAAP;;;;AACA,GArCa;;AAuCAhK,+DAAd,UAAoCmB,EAApC,EAA4C;QAAN4I;;;;;;AACrB;AAAA;AAAA,cAAM3L,IAAI,CAAC6L,cAAL,EAAN;;;AAAVC,mBAAO,GAAG/H,SAAV;AACN;AAAA;AAAA,cAAO;AACNgI,2BAAa,EAAED,OAAO,CAACE,cAAR,GAAyBC,WAAzB,EADT;AAENN,kBAAI;AAFE,aAAP;;;;AAIA,GANa;;AAQA/J,kEAAd,UAAuCmB,EAAvC,EAA+C;QAAN4I;;;;;;AAGlB;AAAA;AAAA,cAAM5L,KAAK,CAACmM,OAAN,CAAc,eAAd,CAAN;;;AAAhBC,yBAAa,GAAGpI,SAAhB;iBACFoI;AAAA;AAAA;AACHC,iBAAK,GAAGD,aAAa,CAACC,KAAtB;;;;;;AAEoB;AAAA;AAAA,cAAMpM,IAAI,CAACqM,wBAAL,EAAN;;;AAAdC,uBAAW,GAAGvI,SAAd;;AACN,gBAAIuI,WAAJ,EAAiB;AAChBF,mBAAK,GAAGE,WAAW,CAACF,KAApB;AACA;;;;;AAEF,gBAAI,CAACA,KAAL,EAAY;AACX,oBAAM,IAAIvK,KAAJ,CAAU,kBAAV,CAAN;AACA;;AACD;AAAA;AAAA,cAAO;AACNkK,2BAAa,EAAEK,KADT;AAENT,kBAAI;AAFE,aAAP;;;;AAIA,GAnBa;;AAqBA/J,kEAAd,UAAuCmB,EAAvC,EAAuD;QAAdc;QAAQ8H;;;;AAC1CY,UAAE,GAAG,IAAIC,IAAJ,EAAL;AACAC,aAAK,GAAGF,EAAE,CAACG,WAAH,GAAiBpD,OAAjB,CAAyB,gBAAzB,EAA2C,EAA3C,CAAR;AAEN;AAAA;AAAA,UAAO;AACNqC,cAAI,MADE;AAEN,wBAAcc,KAFR;AAGN,uBAAa5I;AAHP,SAAP;;;AAKA,GATa;;AAWAjC,+DAAd,UAAoCmB,EAApC,EAKC;QAJA2B;QACAC;QACAxC;QACA2B;;;;;;AAEM6I,wBAAY,GAAG;AACpB7I,oBAAM,QADc;AAEpB8I,qBAAO,EAAE;AAFW,aAAf;AAKgB;AAAA;AAAA,cAAM,KAAKC,kBAAL,EAAN;;;AAAhBC,yBAAa,GAAG/I,SAAhB;;AACN,gBAAI,CAAC+I,aAAL,EAAoB;AACnB,oBAAM,IAAIjL,KAAJ,CAAU,gBAAV,CAAN;AACA;;AACa;AAAA;AAAA,cAAMrC,WAAW,CAAC0D,GAAZ,GAAkB6J,IAAlB,CAAuB,uBAAW;AAAI,qBAAC;AAC1DC,0BAAU,EAAEC,WAAW,CAACC,eADkC;AAE1DC,0BAAU,EAAEF,WAAW,CAACG,WAFkC;AAG1DC,6BAAa,EAAEJ,WAAW,CAACK;AAH+B,eAAD;AAIxD,aAJkB,CAAN;;;AAARC,iBAAK,GAAGxJ,SAAR;AAMAyJ,mBAAO,GAAG;AACfrO,iBAAG,EAAE,KAAGgD,sBAAH,GAA4BwC,YADlB;AAEflE,kBAAI,EAAEiE,OAFS;AAGf+I,oBAAM,EAAE,MAHO;AAIfC,qBAAO,eAAOzM,4BAAP;AAJQ,aAAV;AAOA0M,yBAAa,GAAGlO,MAAM,CAACmO,IAAP,CAAYJ,OAAZ,EAAqBD,KAArB,EAA4BZ,YAA5B,CAAhB;AACN;AAAA;AAAA,cAAOgB,aAAa,CAACD,OAArB;;;;AACA,GA9Ba;;AAgCN9L,2DAAR,UAA0BmB,EAA1B,EAAqD;QAAzB4I;QAAMzH;;AACjC,QAAI,CAACA,iBAAiB,CAAC6H,aAAvB,EAAsC;AACrC,YAAM,IAAIlK,KAAJ,CAAU,yBAAV,CAAN;AACA;;AAED,WAAO;AACNkK,mBAAa,EAAE7H,iBAAiB,CAAC6H,aAD3B;AAENJ,UAAI;AAFE,KAAP;AAIA,GATO;AAWR;;;;;AAGA/J;AACC,WAAOpC,WAAW,CAAC0D,GAAZ,GACL6J,IADK,CACA,uBAAW;AAChB,UAAI,CAACE,WAAL,EAAkB,OAAO,KAAP;AAClB,UAAMY,IAAI,GAAGrO,WAAW,CAACsO,KAAZ,CAAkBb,WAAlB,CAAb;AACA9M,YAAM,CAACkD,KAAP,CAAa,gDAAb,EAA+DwK,IAA/D;AAEA,aAAO,IAAP;AACA,KAPK,EAQLlL,KARK,CAQC,eAAG;AACTxC,YAAM,CAAC4N,IAAP,CAAY,0BAAZ,EAAwClL,GAAxC;AACA,aAAO,KAAP;AACA,KAXK,CAAP;AAYA,GAbD;;AAcD;AA7vBA,EAAgD5C,sBAAhD","names":["Observable","GraphQLError","url","v4","uuid","Buffer","Logger","Credentials","Signer","Hub","Constants","USER_AGENT_HEADER","jitteredExponentialRetry","NonRetryableError","Cache","Auth","AbstractPubSubProvider","CONTROL_MSG","logger","AMPLIFY_SYMBOL","Symbol","for","dispatchApiEvent","event","data","message","dispatch","MAX_DELAY_MS","NON_RETRYABLE_CODES","MESSAGE_TYPES","SUBSCRIPTION_STATUS","SOCKET_STATUS","AWS_APPSYNC_REALTIME_HEADERS","accept","CONNECTION_INIT_TIMEOUT","START_ACK_TIMEOUT","DEFAULT_KEEP_ALIVE_TIMEOUT","standardDomainPattern","customDomainPath","__extends","_this","CLOSED","Map","AWSAppSyncRealTimeProvider","Error","_topics","_msg","_options","match","options","appSyncGraphqlEndpoint","observer","error","errors","complete","subscriptionId_1","_startSubscriptionWithAWSAppSyncRealTime","subscriptionId","catch","REALTIME_SUBSCRIPTION_INIT_ERROR","err","_waitForSubscriptionToBeConnected","_a","subscriptionState","subscriptionObserverMap","get","CONNECTED","_sendUnsubscriptionMessage","debug","err_1","_removeSubscriptionObserver","Object","aws_appsync_dangerously_connect_to_http_endpoint_for_testing","authenticationType","query","variables","apiKey","region","_b","graphql_headers","_c","additionalHeaders","PENDING","set","startAckTimeoutId","dataString","JSON","stringify","_awsRealTimeHeaderBasedAuth","payload","canonicalUri","_j","headerObj","_h","userAgent","subscriptionMessage","id","extensions","authorization","type","GQL_START","stringToAWSRealTime","_initializeWebSocketConnection","_f","err_2","CONNECTION_FAILED","subscriptionFailedCallback_1","subscriptionFailedCallback","_g","subscriptionReadyCallback","setTimeout","_timeoutStartSubscriptionAck","call","awsRealTimeSocket","send","Promise","res","rej","readyState","WebSocket","OPEN","socketStatus","READY","unsubscribeMessage","GQL_STOP","delete","_closeSocketIfRequired","bind","size","bufferedAmount","clearTimeout","keepAliveTimeoutId","tempSocket","onclose","undefined","onerror","close","_d","_e","GQL_DATA","next","GQL_START_ACK","SUBSCRIPTION_ACK","GQL_CONNECTION_KEEP_ALIVE","_errorDisconnect","TIMEOUT_DISCONNECT","keepAliveTimeout","GQL_ERROR","FAILED","msg","forEach","closed","clear","promiseArray","push","CONNECTING","payloadString","headerString","headerQs","from","toString","payloadQs","discoverableEndpoint","isCustomDomain","concat","replace","protocol","isSSLEnabled","awsRealTimeUrl","_initializeRetryableHandshake","err_3","_initializeHandshake","newSocket","onopen","ackOk","reason","onmessage","parse","connectionTimeoutMs","GQL_CONNECTION_ACK","_handleIncomingSubscriptionMessage","CONNECTION_CLOSED","GQL_CONNECTION_ERROR","errorType","errorCode","gqlInit","GQL_CONNECTION_INIT","checkAckOk","err_4","includes","headerHandler","API_KEY","_awsRealTimeApiKeyHeader","AWS_IAM","_awsRealTimeIAMHeader","OPENID_CONNECT","_awsRealTimeOPENIDHeader","AMAZON_COGNITO_USER_POOLS","_awsRealTimeCUPHeader","AWS_LAMBDA","_customAuthHeader","handler","host","result","currentSession","session","Authorization","getAccessToken","getJwtToken","getItem","federatedInfo","token","currentAuthenticatedUser","currentUser","dt","Date","dtStr","toISOString","endpointInfo","service","_ensureCredentials","credentialsOK","then","secret_key","credentials","secretAccessKey","access_key","accessKeyId","session_token","sessionToken","creds","request","method","headers","signed_params","sign","cred","shear","warn"],"sources":["/Users/richards/node_modules/@aws-amplify/pubsub/src/Providers/AWSAppSyncRealTimeProvider.ts"],"sourcesContent":["/*\n * Copyright 2017-2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n *     http://aws.amazon.com/apache2.0/\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\nimport Observable, { ZenObservable } from 'zen-observable-ts';\nimport { GraphQLError } from 'graphql';\nimport * as url from 'url';\nimport { v4 as uuid } from 'uuid';\nimport { Buffer } from 'buffer';\nimport { ProvidertOptions } from '../types';\nimport {\n\tLogger,\n\tCredentials,\n\tSigner,\n\tHub,\n\tConstants,\n\tUSER_AGENT_HEADER,\n\tjitteredExponentialRetry,\n\tNonRetryableError,\n} from '@aws-amplify/core';\nimport Cache from '@aws-amplify/cache';\nimport Auth from '@aws-amplify/auth';\nimport { AbstractPubSubProvider } from './PubSubProvider';\nimport { CONTROL_MSG } from '../index';\n\nconst logger = new Logger('AWSAppSyncRealTimeProvider');\n\nconst AMPLIFY_SYMBOL = (typeof Symbol !== 'undefined' &&\ntypeof Symbol.for === 'function'\n\t? Symbol.for('amplify_default')\n\t: '@@amplify_default') as Symbol;\n\nconst dispatchApiEvent = (event: string, data: any, message: string) => {\n\tHub.dispatch('api', { event, data, message }, 'PubSub', AMPLIFY_SYMBOL);\n};\n\nconst MAX_DELAY_MS = 5000;\n\nconst NON_RETRYABLE_CODES = [400, 401, 403];\n\ntype ObserverQuery = {\n\tobserver: ZenObservable.SubscriptionObserver<any>;\n\tquery: string;\n\tvariables: object;\n\tsubscriptionState: SUBSCRIPTION_STATUS;\n\tsubscriptionReadyCallback?: Function;\n\tsubscriptionFailedCallback?: Function;\n\tstartAckTimeoutId?;\n};\n\nenum MESSAGE_TYPES {\n\t/**\n\t * Client -> Server message.\n\t * This message type is the first message after handshake and this will initialize AWS AppSync RealTime communication\n\t */\n\tGQL_CONNECTION_INIT = 'connection_init',\n\t/**\n\t * Server -> Client message\n\t * This message type is in case there is an issue with AWS AppSync RealTime when establishing connection\n\t */\n\tGQL_CONNECTION_ERROR = 'connection_error',\n\t/**\n\t * Server -> Client message.\n\t * This message type is for the ack response from AWS AppSync RealTime for GQL_CONNECTION_INIT message\n\t */\n\tGQL_CONNECTION_ACK = 'connection_ack',\n\t/**\n\t * Client -> Server message.\n\t * This message type is for register subscriptions with AWS AppSync RealTime\n\t */\n\tGQL_START = 'start',\n\t/**\n\t * Server -> Client message.\n\t * This message type is for the ack response from AWS AppSync RealTime for GQL_START message\n\t */\n\tGQL_START_ACK = 'start_ack',\n\t/**\n\t * Server -> Client message.\n\t * This message type is for subscription message from AWS AppSync RealTime\n\t */\n\tGQL_DATA = 'data',\n\t/**\n\t * Server -> Client message.\n\t * This message type helps the client to know is still receiving messages from AWS AppSync RealTime\n\t */\n\tGQL_CONNECTION_KEEP_ALIVE = 'ka',\n\t/**\n\t * Client -> Server message.\n\t * This message type is for unregister subscriptions with AWS AppSync RealTime\n\t */\n\tGQL_STOP = 'stop',\n\t/**\n\t * Server -> Client message.\n\t * This message type is for the ack response from AWS AppSync RealTime for GQL_STOP message\n\t */\n\tGQL_COMPLETE = 'complete',\n\t/**\n\t * Server -> Client message.\n\t * This message type is for sending error messages from AWS AppSync RealTime to the client\n\t */\n\tGQL_ERROR = 'error', // Server -> Client\n}\n\nenum SUBSCRIPTION_STATUS {\n\tPENDING,\n\tCONNECTED,\n\tFAILED,\n}\n\nenum SOCKET_STATUS {\n\tCLOSED,\n\tREADY,\n\tCONNECTING,\n}\n\nconst AWS_APPSYNC_REALTIME_HEADERS = {\n\taccept: 'application/json, text/javascript',\n\t'content-encoding': 'amz-1.0',\n\t'content-type': 'application/json; charset=UTF-8',\n};\n\n/**\n * Time in milleseconds to wait for GQL_CONNECTION_INIT message\n */\nconst CONNECTION_INIT_TIMEOUT = 15000;\n\n/**\n * Time in milleseconds to wait for GQL_START_ACK message\n */\nconst START_ACK_TIMEOUT = 15000;\n\n/**\n * Default Time in milleseconds to wait for GQL_CONNECTION_KEEP_ALIVE message\n */\nconst DEFAULT_KEEP_ALIVE_TIMEOUT = 5 * 60 * 1000;\n\nconst standardDomainPattern = /^https:\\/\\/\\w{26}\\.appsync\\-api\\.\\w{2}(?:(?:\\-\\w{2,})+)\\-\\d\\.amazonaws.com\\/graphql$/i;\n\nconst customDomainPath = '/realtime';\n\nexport class AWSAppSyncRealTimeProvider extends AbstractPubSubProvider {\n\tprivate awsRealTimeSocket: WebSocket;\n\tprivate socketStatus: SOCKET_STATUS = SOCKET_STATUS.CLOSED;\n\tprivate keepAliveTimeoutId;\n\tprivate keepAliveTimeout = DEFAULT_KEEP_ALIVE_TIMEOUT;\n\tprivate subscriptionObserverMap: Map<string, ObserverQuery> = new Map();\n\tprivate promiseArray: Array<{ res: Function; rej: Function }> = [];\n\n\tgetProviderName() {\n\t\treturn 'AWSAppSyncRealTimeProvider';\n\t}\n\n\tnewClient(): Promise<any> {\n\t\tthrow new Error('Not used here');\n\t}\n\n\tpublic async publish(_topics: string[] | string, _msg: any, _options?: any) {\n\t\tthrow new Error('Operation not supported');\n\t}\n\n\t// Check if url matches standard domain pattern\n\tprivate isCustomDomain(url: string): boolean {\n\t\treturn url.match(standardDomainPattern) === null;\n\t}\n\n\tsubscribe(\n\t\t_topics: string[] | string,\n\t\toptions?: ProvidertOptions\n\t): Observable<any> {\n\t\tconst { appSyncGraphqlEndpoint } = options;\n\n\t\treturn new Observable(observer => {\n\t\t\tif (!appSyncGraphqlEndpoint) {\n\t\t\t\tobserver.error({\n\t\t\t\t\terrors: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t...new GraphQLError(\n\t\t\t\t\t\t\t\t`Subscribe only available for AWS AppSync endpoint`\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t});\n\t\t\t\tobserver.complete();\n\t\t\t} else {\n\t\t\t\tconst subscriptionId = uuid();\n\t\t\t\tthis._startSubscriptionWithAWSAppSyncRealTime({\n\t\t\t\t\toptions,\n\t\t\t\t\tobserver,\n\t\t\t\t\tsubscriptionId,\n\t\t\t\t}).catch(err => {\n\t\t\t\t\tobserver.error({\n\t\t\t\t\t\terrors: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t...new GraphQLError(\n\t\t\t\t\t\t\t\t\t`${CONTROL_MSG.REALTIME_SUBSCRIPTION_INIT_ERROR}: ${err}`\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t],\n\t\t\t\t\t});\n\t\t\t\t\tobserver.complete();\n\t\t\t\t});\n\n\t\t\t\treturn async () => {\n\t\t\t\t\t// Cleanup after unsubscribing or observer.complete was called after _startSubscriptionWithAWSAppSyncRealTime\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Waiting that subscription has been connected before trying to unsubscribe\n\t\t\t\t\t\tawait this._waitForSubscriptionToBeConnected(subscriptionId);\n\n\t\t\t\t\t\tconst { subscriptionState } =\n\t\t\t\t\t\t\tthis.subscriptionObserverMap.get(subscriptionId) || {};\n\n\t\t\t\t\t\tif (!subscriptionState) {\n\t\t\t\t\t\t\t// subscription already unsubscribed\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (subscriptionState === SUBSCRIPTION_STATUS.CONNECTED) {\n\t\t\t\t\t\t\tthis._sendUnsubscriptionMessage(subscriptionId);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow new Error('Subscription never connected');\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tlogger.debug(`Error while unsubscribing ${err}`);\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tthis._removeSubscriptionObserver(subscriptionId);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\t}\n\n\tprotected get isSSLEnabled() {\n\t\treturn !this.options\n\t\t\t.aws_appsync_dangerously_connect_to_http_endpoint_for_testing;\n\t}\n\tprivate async _startSubscriptionWithAWSAppSyncRealTime({\n\t\toptions,\n\t\tobserver,\n\t\tsubscriptionId,\n\t}) {\n\t\tconst {\n\t\t\tappSyncGraphqlEndpoint,\n\t\t\tauthenticationType,\n\t\t\tquery,\n\t\t\tvariables,\n\t\t\tapiKey,\n\t\t\tregion,\n\t\t\tgraphql_headers = () => ({}),\n\t\t\tadditionalHeaders = {},\n\t\t} = options;\n\n\t\tconst subscriptionState: SUBSCRIPTION_STATUS = SUBSCRIPTION_STATUS.PENDING;\n\t\tconst data = {\n\t\t\tquery,\n\t\t\tvariables,\n\t\t};\n\t\t// Having a subscription id map will make it simple to forward messages received\n\t\tthis.subscriptionObserverMap.set(subscriptionId, {\n\t\t\tobserver,\n\t\t\tquery,\n\t\t\tvariables,\n\t\t\tsubscriptionState,\n\t\t\tstartAckTimeoutId: null,\n\t\t});\n\n\t\t// Preparing payload for subscription message\n\n\t\tconst dataString = JSON.stringify(data);\n\t\tconst headerObj = {\n\t\t\t...(await this._awsRealTimeHeaderBasedAuth({\n\t\t\t\tapiKey,\n\t\t\t\tappSyncGraphqlEndpoint,\n\t\t\t\tauthenticationType,\n\t\t\t\tpayload: dataString,\n\t\t\t\tcanonicalUri: '',\n\t\t\t\tregion,\n\t\t\t\tadditionalHeaders,\n\t\t\t})),\n\t\t\t...(await graphql_headers()),\n\t\t\t...additionalHeaders,\n\t\t\t[USER_AGENT_HEADER]: Constants.userAgent,\n\t\t};\n\n\t\tconst subscriptionMessage = {\n\t\t\tid: subscriptionId,\n\t\t\tpayload: {\n\t\t\t\tdata: dataString,\n\t\t\t\textensions: {\n\t\t\t\t\tauthorization: {\n\t\t\t\t\t\t...headerObj,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttype: MESSAGE_TYPES.GQL_START,\n\t\t};\n\n\t\tconst stringToAWSRealTime = JSON.stringify(subscriptionMessage);\n\n\t\ttry {\n\t\t\tawait this._initializeWebSocketConnection({\n\t\t\t\tapiKey,\n\t\t\t\tappSyncGraphqlEndpoint,\n\t\t\t\tauthenticationType,\n\t\t\t\tregion,\n\t\t\t\tadditionalHeaders,\n\t\t\t});\n\t\t} catch (err) {\n\t\t\tlogger.debug({ err });\n\t\t\tconst { message = '' } = err;\n\t\t\tobserver.error({\n\t\t\t\terrors: [\n\t\t\t\t\t{\n\t\t\t\t\t\t...new GraphQLError(`${CONTROL_MSG.CONNECTION_FAILED}: ${message}`),\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t});\n\t\t\tobserver.complete();\n\n\t\t\tconst { subscriptionFailedCallback } =\n\t\t\t\tthis.subscriptionObserverMap.get(subscriptionId) || {};\n\n\t\t\t// Notify concurrent unsubscription\n\t\t\tif (typeof subscriptionFailedCallback === 'function') {\n\t\t\t\tsubscriptionFailedCallback();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// Potential race condition can occur when unsubscribe is called during _initializeWebSocketConnection.\n\t\t// E.g.unsubscribe gets invoked prior to finishing WebSocket handshake or START_ACK.\n\t\t// Both subscriptionFailedCallback and subscriptionReadyCallback are used to synchronized this.\n\n\t\tconst {\n\t\t\tsubscriptionFailedCallback,\n\t\t\tsubscriptionReadyCallback,\n\t\t} = this.subscriptionObserverMap.get(subscriptionId);\n\n\t\t// This must be done before sending the message in order to be listening immediately\n\t\tthis.subscriptionObserverMap.set(subscriptionId, {\n\t\t\tobserver,\n\t\t\tsubscriptionState,\n\t\t\tvariables,\n\t\t\tquery,\n\t\t\tsubscriptionReadyCallback,\n\t\t\tsubscriptionFailedCallback,\n\t\t\tstartAckTimeoutId: setTimeout(() => {\n\t\t\t\tthis._timeoutStartSubscriptionAck.call(this, subscriptionId);\n\t\t\t}, START_ACK_TIMEOUT),\n\t\t});\n\t\tif (this.awsRealTimeSocket) {\n\t\t\tthis.awsRealTimeSocket.send(stringToAWSRealTime);\n\t\t}\n\t}\n\n\t// Waiting that subscription has been connected before trying to unsubscribe\n\tprivate async _waitForSubscriptionToBeConnected(subscriptionId) {\n\t\tconst { subscriptionState } = this.subscriptionObserverMap.get(\n\t\t\tsubscriptionId\n\t\t);\n\t\t// This in case unsubscribe is invoked before sending start subscription message\n\t\tif (subscriptionState === SUBSCRIPTION_STATUS.PENDING) {\n\t\t\treturn new Promise((res, rej) => {\n\t\t\t\tconst {\n\t\t\t\t\tobserver,\n\t\t\t\t\tsubscriptionState,\n\t\t\t\t\tvariables,\n\t\t\t\t\tquery,\n\t\t\t\t} = this.subscriptionObserverMap.get(subscriptionId);\n\t\t\t\tthis.subscriptionObserverMap.set(subscriptionId, {\n\t\t\t\t\tobserver,\n\t\t\t\t\tsubscriptionState,\n\t\t\t\t\tvariables,\n\t\t\t\t\tquery,\n\t\t\t\t\tsubscriptionReadyCallback: res,\n\t\t\t\t\tsubscriptionFailedCallback: rej,\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate _sendUnsubscriptionMessage(subscriptionId) {\n\t\ttry {\n\t\t\tif (\n\t\t\t\tthis.awsRealTimeSocket &&\n\t\t\t\tthis.awsRealTimeSocket.readyState === WebSocket.OPEN &&\n\t\t\t\tthis.socketStatus === SOCKET_STATUS.READY\n\t\t\t) {\n\t\t\t\t// Preparing unsubscribe message to stop receiving messages for that subscription\n\t\t\t\tconst unsubscribeMessage = {\n\t\t\t\t\tid: subscriptionId,\n\t\t\t\t\ttype: MESSAGE_TYPES.GQL_STOP,\n\t\t\t\t};\n\t\t\t\tconst stringToAWSRealTime = JSON.stringify(unsubscribeMessage);\n\t\t\t\tthis.awsRealTimeSocket.send(stringToAWSRealTime);\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t// If GQL_STOP is not sent because of disconnection issue, then there is nothing the client can do\n\t\t\tlogger.debug({ err });\n\t\t}\n\t}\n\n\tprivate _removeSubscriptionObserver(subscriptionId) {\n\t\tthis.subscriptionObserverMap.delete(subscriptionId);\n\n\t\t// Verifying 1000ms after removing subscription in case there are new subscription unmount/mount\n\t\tsetTimeout(this._closeSocketIfRequired.bind(this), 1000);\n\t}\n\n\tprivate _closeSocketIfRequired() {\n\t\tif (this.subscriptionObserverMap.size > 0) {\n\t\t\t// Active subscriptions on the WebSocket\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.awsRealTimeSocket) {\n\t\t\tthis.socketStatus = SOCKET_STATUS.CLOSED;\n\t\t\treturn;\n\t\t}\n\t\tif (this.awsRealTimeSocket.bufferedAmount > 0) {\n\t\t\t// Still data on the WebSocket\n\t\t\tsetTimeout(this._closeSocketIfRequired.bind(this), 1000);\n\t\t} else {\n\t\t\tlogger.debug('closing WebSocket...');\n\t\t\tclearTimeout(this.keepAliveTimeoutId);\n\t\t\tconst tempSocket = this.awsRealTimeSocket;\n\t\t\t// Cleaning callbacks to avoid race condition, socket still exists\n\t\t\ttempSocket.onclose = undefined;\n\t\t\ttempSocket.onerror = undefined;\n\t\t\ttempSocket.close(1000);\n\t\t\tthis.awsRealTimeSocket = null;\n\t\t\tthis.socketStatus = SOCKET_STATUS.CLOSED;\n\t\t}\n\t}\n\n\tprivate _handleIncomingSubscriptionMessage(message: MessageEvent) {\n\t\tlogger.debug(\n\t\t\t`subscription message from AWS AppSync RealTime: ${message.data}`\n\t\t);\n\t\tconst { id = '', payload, type } = JSON.parse(message.data);\n\t\tconst {\n\t\t\tobserver = null,\n\t\t\tquery = '',\n\t\t\tvariables = {},\n\t\t\tstartAckTimeoutId,\n\t\t\tsubscriptionReadyCallback,\n\t\t\tsubscriptionFailedCallback,\n\t\t} = this.subscriptionObserverMap.get(id) || {};\n\n\t\tlogger.debug({ id, observer, query, variables });\n\n\t\tif (type === MESSAGE_TYPES.GQL_DATA && payload && payload.data) {\n\t\t\tif (observer) {\n\t\t\t\tobserver.next(payload);\n\t\t\t} else {\n\t\t\t\tlogger.debug(`observer not found for id: ${id}`);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (type === MESSAGE_TYPES.GQL_START_ACK) {\n\t\t\tlogger.debug(\n\t\t\t\t`subscription ready for ${JSON.stringify({ query, variables })}`\n\t\t\t);\n\t\t\tif (typeof subscriptionReadyCallback === 'function') {\n\t\t\t\tsubscriptionReadyCallback();\n\t\t\t}\n\t\t\tclearTimeout(startAckTimeoutId);\n\t\t\tdispatchApiEvent(\n\t\t\t\tCONTROL_MSG.SUBSCRIPTION_ACK,\n\t\t\t\t{ query, variables },\n\t\t\t\t'Connection established for subscription'\n\t\t\t);\n\t\t\tconst subscriptionState = SUBSCRIPTION_STATUS.CONNECTED;\n\t\t\tthis.subscriptionObserverMap.set(id, {\n\t\t\t\tobserver,\n\t\t\t\tquery,\n\t\t\t\tvariables,\n\t\t\t\tstartAckTimeoutId: null,\n\t\t\t\tsubscriptionState,\n\t\t\t\tsubscriptionReadyCallback,\n\t\t\t\tsubscriptionFailedCallback,\n\t\t\t});\n\n\t\t\t// TODO: emit event on hub but it requires to store the id first\n\t\t\treturn;\n\t\t}\n\n\t\tif (type === MESSAGE_TYPES.GQL_CONNECTION_KEEP_ALIVE) {\n\t\t\tclearTimeout(this.keepAliveTimeoutId);\n\t\t\tthis.keepAliveTimeoutId = setTimeout(\n\t\t\t\tthis._errorDisconnect.bind(this, CONTROL_MSG.TIMEOUT_DISCONNECT),\n\t\t\t\tthis.keepAliveTimeout\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\tif (type === MESSAGE_TYPES.GQL_ERROR) {\n\t\t\tconst subscriptionState = SUBSCRIPTION_STATUS.FAILED;\n\t\t\tthis.subscriptionObserverMap.set(id, {\n\t\t\t\tobserver,\n\t\t\t\tquery,\n\t\t\t\tvariables,\n\t\t\t\tstartAckTimeoutId,\n\t\t\t\tsubscriptionReadyCallback,\n\t\t\t\tsubscriptionFailedCallback,\n\t\t\t\tsubscriptionState,\n\t\t\t});\n\n\t\t\tobserver.error({\n\t\t\t\terrors: [\n\t\t\t\t\t{\n\t\t\t\t\t\t...new GraphQLError(\n\t\t\t\t\t\t\t`${CONTROL_MSG.CONNECTION_FAILED}: ${JSON.stringify(payload)}`\n\t\t\t\t\t\t),\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t});\n\t\t\tclearTimeout(startAckTimeoutId);\n\n\t\t\tobserver.complete();\n\t\t\tif (typeof subscriptionFailedCallback === 'function') {\n\t\t\t\tsubscriptionFailedCallback();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _errorDisconnect(msg: string) {\n\t\tlogger.debug(`Disconnect error: ${msg}`);\n\t\tthis.subscriptionObserverMap.forEach(({ observer }) => {\n\t\t\tif (observer && !observer.closed) {\n\t\t\t\tobserver.error({\n\t\t\t\t\terrors: [{ ...new GraphQLError(msg) }],\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t\tthis.subscriptionObserverMap.clear();\n\t\tif (this.awsRealTimeSocket) {\n\t\t\tthis.awsRealTimeSocket.close();\n\t\t}\n\n\t\tthis.socketStatus = SOCKET_STATUS.CLOSED;\n\t}\n\n\tprivate _timeoutStartSubscriptionAck(subscriptionId) {\n\t\tconst { observer, query, variables } =\n\t\t\tthis.subscriptionObserverMap.get(subscriptionId) || {};\n\t\tif (!observer) {\n\t\t\treturn;\n\t\t}\n\t\tthis.subscriptionObserverMap.set(subscriptionId, {\n\t\t\tobserver,\n\t\t\tquery,\n\t\t\tvariables,\n\t\t\tsubscriptionState: SUBSCRIPTION_STATUS.FAILED,\n\t\t});\n\n\t\tif (observer && !observer.closed) {\n\t\t\tobserver.error({\n\t\t\t\terrors: [\n\t\t\t\t\t{\n\t\t\t\t\t\t...new GraphQLError(\n\t\t\t\t\t\t\t`Subscription timeout ${JSON.stringify({\n\t\t\t\t\t\t\t\tquery,\n\t\t\t\t\t\t\t\tvariables,\n\t\t\t\t\t\t\t})}`\n\t\t\t\t\t\t),\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t});\n\t\t\t// Cleanup will be automatically executed\n\t\t\tobserver.complete();\n\t\t}\n\t\tlogger.debug(\n\t\t\t'timeoutStartSubscription',\n\t\t\tJSON.stringify({ query, variables })\n\t\t);\n\t}\n\n\tprivate _initializeWebSocketConnection({\n\t\tappSyncGraphqlEndpoint,\n\t\tauthenticationType,\n\t\tapiKey,\n\t\tregion,\n\t\tadditionalHeaders,\n\t}) {\n\t\tif (this.socketStatus === SOCKET_STATUS.READY) {\n\t\t\treturn;\n\t\t}\n\t\treturn new Promise(async (res, rej) => {\n\t\t\tthis.promiseArray.push({ res, rej });\n\n\t\t\tif (this.socketStatus === SOCKET_STATUS.CLOSED) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.socketStatus = SOCKET_STATUS.CONNECTING;\n\n\t\t\t\t\tconst payloadString = '{}';\n\t\t\t\t\tconst headerString = JSON.stringify(\n\t\t\t\t\t\tawait this._awsRealTimeHeaderBasedAuth({\n\t\t\t\t\t\t\tauthenticationType,\n\t\t\t\t\t\t\tpayload: payloadString,\n\t\t\t\t\t\t\tcanonicalUri: '/connect',\n\t\t\t\t\t\t\tapiKey,\n\t\t\t\t\t\t\tappSyncGraphqlEndpoint,\n\t\t\t\t\t\t\tregion,\n\t\t\t\t\t\t\tadditionalHeaders,\n\t\t\t\t\t\t})\n\t\t\t\t\t);\n\t\t\t\t\tconst headerQs = Buffer.from(headerString).toString('base64');\n\n\t\t\t\t\tconst payloadQs = Buffer.from(payloadString).toString('base64');\n\n\t\t\t\t\tlet discoverableEndpoint = appSyncGraphqlEndpoint;\n\n\t\t\t\t\tif (this.isCustomDomain(discoverableEndpoint)) {\n\t\t\t\t\t\tdiscoverableEndpoint = discoverableEndpoint.concat(\n\t\t\t\t\t\t\tcustomDomainPath\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdiscoverableEndpoint = discoverableEndpoint.replace('appsync-api', 'appsync-realtime-api').replace('gogi-beta', 'grt-beta');\n\t\t\t\t\t}\n\n\t\t\t\t    // Creating websocket url with required query strings\n\t\t\t\t\tconst protocol = this.isSSLEnabled ? 'wss://' : 'ws://';\n\t\t\t\t\tdiscoverableEndpoint = discoverableEndpoint\n\t\t\t\t\t\t.replace('https://', protocol)\n\t\t\t\t\t\t.replace('http://', protocol);\n\n\t\t\t\t\tconst awsRealTimeUrl = `${discoverableEndpoint}?header=${headerQs}&payload=${payloadQs}`;\n\n\t\t\t\t\tawait this._initializeRetryableHandshake({ awsRealTimeUrl });\n\n\t\t\t\t\tthis.promiseArray.forEach(({ res }) => {\n\t\t\t\t\t\tlogger.debug('Notifying connection successful');\n\t\t\t\t\t\tres();\n\t\t\t\t\t});\n\t\t\t\t\tthis.socketStatus = SOCKET_STATUS.READY;\n\t\t\t\t\tthis.promiseArray = [];\n\t\t\t\t} catch (err) {\n\t\t\t\t\tthis.promiseArray.forEach(({ rej }) => rej(err));\n\t\t\t\t\tthis.promiseArray = [];\n\t\t\t\t\tif (\n\t\t\t\t\t\tthis.awsRealTimeSocket &&\n\t\t\t\t\t\tthis.awsRealTimeSocket.readyState === WebSocket.OPEN\n\t\t\t\t\t) {\n\t\t\t\t\t\tthis.awsRealTimeSocket.close(3001);\n\t\t\t\t\t}\n\t\t\t\t\tthis.awsRealTimeSocket = null;\n\t\t\t\t\tthis.socketStatus = SOCKET_STATUS.CLOSED;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate async _initializeRetryableHandshake({ awsRealTimeUrl }) {\n\t\tlogger.debug(`Initializaling retryable Handshake`);\n\t\tawait jitteredExponentialRetry(\n\t\t\tthis._initializeHandshake.bind(this),\n\t\t\t[{ awsRealTimeUrl }],\n\t\t\tMAX_DELAY_MS\n\t\t);\n\t}\n\n\tprivate async _initializeHandshake({ awsRealTimeUrl }) {\n\t\tlogger.debug(`Initializing handshake ${awsRealTimeUrl}`);\n\t\t// Because connecting the socket is async, is waiting until connection is open\n\t\t// Step 1: connect websocket\n\t\ttry {\n\t\t\tawait (() => {\n\t\t\t\treturn new Promise<void>((res, rej) => {\n\t\t\t\t\tconst newSocket = new WebSocket(awsRealTimeUrl, 'graphql-ws');\n\t\t\t\t\tnewSocket.onerror = () => {\n\t\t\t\t\t\tlogger.debug(`WebSocket connection error`);\n\t\t\t\t\t};\n\t\t\t\t\tnewSocket.onclose = () => {\n\t\t\t\t\t\trej(new Error('Connection handshake error'));\n\t\t\t\t\t};\n\t\t\t\t\tnewSocket.onopen = () => {\n\t\t\t\t\t\tthis.awsRealTimeSocket = newSocket;\n\t\t\t\t\t\treturn res();\n\t\t\t\t\t};\n\t\t\t\t});\n\t\t\t})();\n\n\t\t\t// Step 2: wait for ack from AWS AppSyncReaTime after sending init\n\t\t\tawait (() => {\n\t\t\t\treturn new Promise((res, rej) => {\n\t\t\t\t\tlet ackOk = false;\n\t\t\t\t\tthis.awsRealTimeSocket.onerror = error => {\n\t\t\t\t\t\tlogger.debug(`WebSocket error ${JSON.stringify(error)}`);\n\t\t\t\t\t};\n\t\t\t\t\tthis.awsRealTimeSocket.onclose = event => {\n\t\t\t\t\t\tlogger.debug(`WebSocket closed ${event.reason}`);\n\t\t\t\t\t\trej(new Error(JSON.stringify(event)));\n\t\t\t\t\t};\n\n\t\t\t\t\tthis.awsRealTimeSocket.onmessage = (message: MessageEvent) => {\n\t\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t\t`subscription message from AWS AppSyncRealTime: ${message.data} `\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst data = JSON.parse(message.data);\n\t\t\t\t\t\tconst {\n\t\t\t\t\t\t\ttype,\n\t\t\t\t\t\t\tpayload: {\n\t\t\t\t\t\t\t\tconnectionTimeoutMs = DEFAULT_KEEP_ALIVE_TIMEOUT,\n\t\t\t\t\t\t\t} = {},\n\t\t\t\t\t\t} = data;\n\t\t\t\t\t\tif (type === MESSAGE_TYPES.GQL_CONNECTION_ACK) {\n\t\t\t\t\t\t\tackOk = true;\n\t\t\t\t\t\t\tthis.keepAliveTimeout = connectionTimeoutMs;\n\t\t\t\t\t\t\tthis.awsRealTimeSocket.onmessage = this._handleIncomingSubscriptionMessage.bind(\n\t\t\t\t\t\t\t\tthis\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tthis.awsRealTimeSocket.onerror = err => {\n\t\t\t\t\t\t\t\tlogger.debug(err);\n\t\t\t\t\t\t\t\tthis._errorDisconnect(CONTROL_MSG.CONNECTION_CLOSED);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tthis.awsRealTimeSocket.onclose = event => {\n\t\t\t\t\t\t\t\tlogger.debug(`WebSocket closed ${event.reason}`);\n\t\t\t\t\t\t\t\tthis._errorDisconnect(CONTROL_MSG.CONNECTION_CLOSED);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tres('Cool, connected to AWS AppSyncRealTime');\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (type === MESSAGE_TYPES.GQL_CONNECTION_ERROR) {\n\t\t\t\t\t\t\tconst {\n\t\t\t\t\t\t\t\tpayload: {\n\t\t\t\t\t\t\t\t\terrors: [{ errorType = '', errorCode = 0 } = {}] = [],\n\t\t\t\t\t\t\t\t} = {},\n\t\t\t\t\t\t\t} = data;\n\n\t\t\t\t\t\t\trej({ errorType, errorCode });\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tconst gqlInit = {\n\t\t\t\t\t\ttype: MESSAGE_TYPES.GQL_CONNECTION_INIT,\n\t\t\t\t\t};\n\t\t\t\t\tthis.awsRealTimeSocket.send(JSON.stringify(gqlInit));\n\n\t\t\t\t\tfunction checkAckOk() {\n\t\t\t\t\t\tif (!ackOk) {\n\t\t\t\t\t\t\trej(\n\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t`Connection timeout: ack from AWSRealTime was not received on ${CONNECTION_INIT_TIMEOUT} ms`\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tsetTimeout(checkAckOk.bind(this), CONNECTION_INIT_TIMEOUT);\n\t\t\t\t});\n\t\t\t})();\n\t\t} catch (err) {\n\t\t\tconst { errorType, errorCode } = err;\n\n\t\t\tif (NON_RETRYABLE_CODES.includes(errorCode)) {\n\t\t\t\tthrow new NonRetryableError(errorType);\n\t\t\t} else if (errorType) {\n\t\t\t\tthrow new Error(errorType);\n\t\t\t} else {\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async _awsRealTimeHeaderBasedAuth({\n\t\tauthenticationType,\n\t\tpayload,\n\t\tcanonicalUri,\n\t\tappSyncGraphqlEndpoint,\n\t\tapiKey,\n\t\tregion,\n\t\tadditionalHeaders,\n\t}): Promise<any> {\n\t\tconst headerHandler = {\n\t\t\tAPI_KEY: this._awsRealTimeApiKeyHeader.bind(this),\n\t\t\tAWS_IAM: this._awsRealTimeIAMHeader.bind(this),\n\t\t\tOPENID_CONNECT: this._awsRealTimeOPENIDHeader.bind(this),\n\t\t\tAMAZON_COGNITO_USER_POOLS: this._awsRealTimeCUPHeader.bind(this),\n\t\t\tAWS_LAMBDA: this._customAuthHeader,\n\t\t};\n\n\t\tconst handler = headerHandler[authenticationType];\n\n\t\tif (typeof handler !== 'function') {\n\t\t\tlogger.debug(`Authentication type ${authenticationType} not supported`);\n\t\t\treturn '';\n\t\t}\n\n\t\tconst { host } = url.parse(appSyncGraphqlEndpoint);\n\n\t\tconst result = await handler({\n\t\t\tpayload,\n\t\t\tcanonicalUri,\n\t\t\tappSyncGraphqlEndpoint,\n\t\t\tapiKey,\n\t\t\tregion,\n\t\t\thost,\n\t\t\tadditionalHeaders,\n\t\t});\n\n\t\treturn result;\n\t}\n\n\tprivate async _awsRealTimeCUPHeader({ host }) {\n\t\tconst session = await Auth.currentSession();\n\t\treturn {\n\t\t\tAuthorization: session.getAccessToken().getJwtToken(),\n\t\t\thost,\n\t\t};\n\t}\n\n\tprivate async _awsRealTimeOPENIDHeader({ host }) {\n\t\tlet token;\n\t\t// backwards compatibility\n\t\tconst federatedInfo = await Cache.getItem('federatedInfo');\n\t\tif (federatedInfo) {\n\t\t\ttoken = federatedInfo.token;\n\t\t} else {\n\t\t\tconst currentUser = await Auth.currentAuthenticatedUser();\n\t\t\tif (currentUser) {\n\t\t\t\ttoken = currentUser.token;\n\t\t\t}\n\t\t}\n\t\tif (!token) {\n\t\t\tthrow new Error('No federated jwt');\n\t\t}\n\t\treturn {\n\t\t\tAuthorization: token,\n\t\t\thost,\n\t\t};\n\t}\n\n\tprivate async _awsRealTimeApiKeyHeader({ apiKey, host }) {\n\t\tconst dt = new Date();\n\t\tconst dtStr = dt.toISOString().replace(/[:\\-]|\\.\\d{3}/g, '');\n\n\t\treturn {\n\t\t\thost,\n\t\t\t'x-amz-date': dtStr,\n\t\t\t'x-api-key': apiKey,\n\t\t};\n\t}\n\n\tprivate async _awsRealTimeIAMHeader({\n\t\tpayload,\n\t\tcanonicalUri,\n\t\tappSyncGraphqlEndpoint,\n\t\tregion,\n\t}) {\n\t\tconst endpointInfo = {\n\t\t\tregion,\n\t\t\tservice: 'appsync',\n\t\t};\n\n\t\tconst credentialsOK = await this._ensureCredentials();\n\t\tif (!credentialsOK) {\n\t\t\tthrow new Error('No credentials');\n\t\t}\n\t\tconst creds = await Credentials.get().then(credentials => ({\n\t\t\tsecret_key: credentials.secretAccessKey,\n\t\t\taccess_key: credentials.accessKeyId,\n\t\t\tsession_token: credentials.sessionToken,\n\t\t}));\n\n\t\tconst request = {\n\t\t\turl: `${appSyncGraphqlEndpoint}${canonicalUri}`,\n\t\t\tdata: payload,\n\t\t\tmethod: 'POST',\n\t\t\theaders: { ...AWS_APPSYNC_REALTIME_HEADERS },\n\t\t};\n\n\t\tconst signed_params = Signer.sign(request, creds, endpointInfo);\n\t\treturn signed_params.headers;\n\t}\n\n\tprivate _customAuthHeader({ host, additionalHeaders }) {\n\t\tif (!additionalHeaders.Authorization) {\n\t\t\tthrow new Error('No auth token specified');\n\t\t}\n\n\t\treturn {\n\t\t\tAuthorization: additionalHeaders.Authorization,\n\t\t\thost,\n\t\t};\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_ensureCredentials() {\n\t\treturn Credentials.get()\n\t\t\t.then(credentials => {\n\t\t\t\tif (!credentials) return false;\n\t\t\t\tconst cred = Credentials.shear(credentials);\n\t\t\t\tlogger.debug('set credentials for AWSAppSyncRealTimeProvider', cred);\n\n\t\t\t\treturn true;\n\t\t\t})\n\t\t\t.catch(err => {\n\t\t\t\tlogger.warn('ensure credentials error', err);\n\t\t\t\treturn false;\n\t\t\t});\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}