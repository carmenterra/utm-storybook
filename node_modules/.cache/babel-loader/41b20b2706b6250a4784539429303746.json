{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nvar __spread = this && this.__spread || function () {\n  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n\n  return ar;\n};\n\nimport { browserOrNode, ConsoleLogger as Logger } from '@aws-amplify/core';\nimport { CONTROL_MSG as PUBSUB_CONTROL_MSG } from '@aws-amplify/pubsub';\nimport Observable from 'zen-observable-ts';\nimport { ModelPredicateCreator } from '../predicates';\nimport { OpType } from '../types';\nimport { exhaustiveCheck, getNow, SYNC, USER } from '../util';\nimport DataStoreConnectivity from './datastoreConnectivity';\nimport { ModelMerger } from './merger';\nimport { MutationEventOutbox } from './outbox';\nimport { MutationProcessor } from './processors/mutation';\nimport { CONTROL_MSG, SubscriptionProcessor } from './processors/subscription';\nimport { SyncProcessor } from './processors/sync';\nimport { createMutationInstanceFromModelOperation, predicateToGraphQLCondition } from './utils';\nvar isNode = browserOrNode().isNode;\nvar logger = new Logger('DataStore');\nvar ownSymbol = Symbol('sync');\nexport var ControlMessage;\n\n(function (ControlMessage) {\n  ControlMessage[\"SYNC_ENGINE_STORAGE_SUBSCRIBED\"] = \"storageSubscribed\";\n  ControlMessage[\"SYNC_ENGINE_SUBSCRIPTIONS_ESTABLISHED\"] = \"subscriptionsEstablished\";\n  ControlMessage[\"SYNC_ENGINE_SYNC_QUERIES_STARTED\"] = \"syncQueriesStarted\";\n  ControlMessage[\"SYNC_ENGINE_SYNC_QUERIES_READY\"] = \"syncQueriesReady\";\n  ControlMessage[\"SYNC_ENGINE_MODEL_SYNCED\"] = \"modelSynced\";\n  ControlMessage[\"SYNC_ENGINE_OUTBOX_MUTATION_ENQUEUED\"] = \"outboxMutationEnqueued\";\n  ControlMessage[\"SYNC_ENGINE_OUTBOX_MUTATION_PROCESSED\"] = \"outboxMutationProcessed\";\n  ControlMessage[\"SYNC_ENGINE_OUTBOX_STATUS\"] = \"outboxStatus\";\n  ControlMessage[\"SYNC_ENGINE_NETWORK_STATUS\"] = \"networkStatus\";\n  ControlMessage[\"SYNC_ENGINE_READY\"] = \"ready\";\n})(ControlMessage || (ControlMessage = {}));\n\nvar SyncEngine =\n/** @class */\nfunction () {\n  function SyncEngine(schema, namespaceResolver, modelClasses, userModelClasses, storage, modelInstanceCreator, maxRecordsToSync, syncPageSize, conflictHandler, errorHandler, syncPredicates, amplifyConfig, authModeStrategy) {\n    if (amplifyConfig === void 0) {\n      amplifyConfig = {};\n    }\n\n    this.schema = schema;\n    this.namespaceResolver = namespaceResolver;\n    this.modelClasses = modelClasses;\n    this.userModelClasses = userModelClasses;\n    this.storage = storage;\n    this.modelInstanceCreator = modelInstanceCreator;\n    this.maxRecordsToSync = maxRecordsToSync;\n    this.syncPageSize = syncPageSize;\n    this.syncPredicates = syncPredicates;\n    this.amplifyConfig = amplifyConfig;\n    this.authModeStrategy = authModeStrategy;\n    this.online = false;\n    this.modelSyncedStatus = new WeakMap();\n    var MutationEvent = this.modelClasses['MutationEvent'];\n    this.outbox = new MutationEventOutbox(this.schema, MutationEvent, modelInstanceCreator, ownSymbol);\n    this.modelMerger = new ModelMerger(this.outbox, ownSymbol);\n    this.syncQueriesProcessor = new SyncProcessor(this.schema, this.syncPredicates, this.amplifyConfig, this.authModeStrategy);\n    this.subscriptionsProcessor = new SubscriptionProcessor(this.schema, this.syncPredicates, this.amplifyConfig, this.authModeStrategy);\n    this.mutationsProcessor = new MutationProcessor(this.schema, this.storage, this.userModelClasses, this.outbox, this.modelInstanceCreator, MutationEvent, this.amplifyConfig, this.authModeStrategy, conflictHandler, errorHandler);\n    this.datastoreConnectivity = new DataStoreConnectivity();\n  }\n\n  SyncEngine.prototype.getModelSyncedStatus = function (modelConstructor) {\n    return this.modelSyncedStatus.get(modelConstructor);\n  };\n\n  SyncEngine.prototype.start = function (params) {\n    var _this = this;\n\n    return new Observable(function (observer) {\n      logger.log('starting sync engine...');\n      var subscriptions = [];\n\n      (function () {\n        return __awaiter(_this, void 0, void 0, function () {\n          var err_1, startPromise, hasMutationsInOutbox;\n\n          var _this = this;\n\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                _a.trys.push([0, 2,, 3]);\n\n                return [4\n                /*yield*/\n                , this.setupModels(params)];\n\n              case 1:\n                _a.sent();\n\n                return [3\n                /*break*/\n                , 3];\n\n              case 2:\n                err_1 = _a.sent();\n                observer.error(err_1);\n                return [2\n                /*return*/\n                ];\n\n              case 3:\n                startPromise = new Promise(function (resolve) {\n                  _this.datastoreConnectivity.status().subscribe(function (_a) {\n                    var online = _a.online;\n                    return __awaiter(_this, void 0, void 0, function () {\n                      var ctlSubsObservable_1, dataSubsObservable, err_2, error_1;\n\n                      var _b;\n\n                      var _this = this;\n\n                      return __generator(this, function (_c) {\n                        switch (_c.label) {\n                          case 0:\n                            if (!(online && !this.online)) return [3\n                            /*break*/\n                            , 10];\n                            this.online = online;\n                            observer.next({\n                              type: ControlMessage.SYNC_ENGINE_NETWORK_STATUS,\n                              data: {\n                                active: this.online\n                              }\n                            });\n                            dataSubsObservable = void 0;\n                            if (!isNode) return [3\n                            /*break*/\n                            , 1];\n                            logger.warn('Realtime disabled when in a server-side environment');\n                            return [3\n                            /*break*/\n                            , 6];\n\n                          case 1:\n                            //#region GraphQL Subscriptions\n                            _b = __read(this.subscriptionsProcessor.start(), 2), // const ctlObservable: Observable<CONTROL_MSG>\n                            ctlSubsObservable_1 = _b[0], // const dataObservable: Observable<[TransformerMutationType, SchemaModel, Readonly<{\n                            // id: string;\n                            // } & Record<string, any>>]>\n                            dataSubsObservable = _b[1];\n                            _c.label = 2;\n\n                          case 2:\n                            _c.trys.push([2, 4,, 5]);\n\n                            return [4\n                            /*yield*/\n                            , new Promise(function (resolve, reject) {\n                              var ctlSubsSubscription = ctlSubsObservable_1.subscribe({\n                                next: function (msg) {\n                                  if (msg === CONTROL_MSG.CONNECTED) {\n                                    resolve();\n                                  }\n                                },\n                                error: function (err) {\n                                  reject(err);\n\n                                  var handleDisconnect = _this.disconnectionHandler();\n\n                                  handleDisconnect(err);\n                                }\n                              });\n                              subscriptions.push(ctlSubsSubscription);\n                            })];\n\n                          case 3:\n                            _c.sent();\n\n                            return [3\n                            /*break*/\n                            , 5];\n\n                          case 4:\n                            err_2 = _c.sent();\n                            observer.error(err_2);\n                            return [2\n                            /*return*/\n                            ];\n\n                          case 5:\n                            logger.log('Realtime ready');\n                            observer.next({\n                              type: ControlMessage.SYNC_ENGINE_SUBSCRIPTIONS_ESTABLISHED\n                            });\n                            _c.label = 6;\n\n                          case 6:\n                            _c.trys.push([6, 8,, 9]);\n\n                            return [4\n                            /*yield*/\n                            , new Promise(function (resolve, reject) {\n                              var syncQuerySubscription = _this.syncQueriesObservable().subscribe({\n                                next: function (message) {\n                                  var type = message.type;\n\n                                  if (type === ControlMessage.SYNC_ENGINE_SYNC_QUERIES_READY) {\n                                    resolve();\n                                  }\n\n                                  observer.next(message);\n                                },\n                                complete: function () {\n                                  resolve();\n                                },\n                                error: function (error) {\n                                  reject(error);\n                                }\n                              });\n\n                              if (syncQuerySubscription) {\n                                subscriptions.push(syncQuerySubscription);\n                              }\n                            })];\n\n                          case 7:\n                            _c.sent();\n\n                            return [3\n                            /*break*/\n                            , 9];\n\n                          case 8:\n                            error_1 = _c.sent();\n                            observer.error(error_1);\n                            return [2\n                            /*return*/\n                            ];\n\n                          case 9:\n                            //#endregion\n                            //#region process mutations\n                            subscriptions.push(this.mutationsProcessor.start().subscribe(function (_a) {\n                              var modelDefinition = _a.modelDefinition,\n                                  item = _a.model,\n                                  hasMore = _a.hasMore;\n                              var modelConstructor = _this.userModelClasses[modelDefinition.name];\n\n                              var model = _this.modelInstanceCreator(modelConstructor, item);\n\n                              _this.storage.runExclusive(function (storage) {\n                                return _this.modelMerger.merge(storage, model);\n                              });\n\n                              observer.next({\n                                type: ControlMessage.SYNC_ENGINE_OUTBOX_MUTATION_PROCESSED,\n                                data: {\n                                  model: modelConstructor,\n                                  element: model\n                                }\n                              });\n                              observer.next({\n                                type: ControlMessage.SYNC_ENGINE_OUTBOX_STATUS,\n                                data: {\n                                  isEmpty: !hasMore\n                                }\n                              });\n                            })); //#endregion\n                            //#region Merge subscriptions buffer\n                            // TODO: extract to function\n\n                            if (!isNode) {\n                              subscriptions.push(dataSubsObservable.subscribe(function (_a) {\n                                var _b = __read(_a, 3),\n                                    _transformerMutationType = _b[0],\n                                    modelDefinition = _b[1],\n                                    item = _b[2];\n\n                                var modelConstructor = _this.userModelClasses[modelDefinition.name];\n\n                                var model = _this.modelInstanceCreator(modelConstructor, item);\n\n                                _this.storage.runExclusive(function (storage) {\n                                  return _this.modelMerger.merge(storage, model);\n                                });\n                              }));\n                            }\n\n                            return [3\n                            /*break*/\n                            , 11];\n\n                          case 10:\n                            if (!online) {\n                              this.online = online;\n                              observer.next({\n                                type: ControlMessage.SYNC_ENGINE_NETWORK_STATUS,\n                                data: {\n                                  active: this.online\n                                }\n                              });\n                              subscriptions.forEach(function (sub) {\n                                return sub.unsubscribe();\n                              });\n                              subscriptions = [];\n                            }\n\n                            _c.label = 11;\n\n                          case 11:\n                            resolve();\n                            return [2\n                            /*return*/\n                            ];\n                        }\n                      });\n                    });\n                  });\n                });\n                this.storage.observe(null, null, ownSymbol).filter(function (_a) {\n                  var model = _a.model;\n\n                  var modelDefinition = _this.getModelDefinition(model);\n\n                  return modelDefinition.syncable === true;\n                }).subscribe({\n                  next: function (_a) {\n                    var opType = _a.opType,\n                        model = _a.model,\n                        element = _a.element,\n                        condition = _a.condition;\n                    return __awaiter(_this, void 0, void 0, function () {\n                      var namespace, MutationEventConstructor, graphQLCondition, mutationEvent;\n                      return __generator(this, function (_b) {\n                        switch (_b.label) {\n                          case 0:\n                            namespace = this.schema.namespaces[this.namespaceResolver(model)];\n                            MutationEventConstructor = this.modelClasses['MutationEvent'];\n                            graphQLCondition = predicateToGraphQLCondition(condition);\n                            mutationEvent = createMutationInstanceFromModelOperation(namespace.relationships, this.getModelDefinition(model), opType, model, element, graphQLCondition, MutationEventConstructor, this.modelInstanceCreator);\n                            return [4\n                            /*yield*/\n                            , this.outbox.enqueue(this.storage, mutationEvent)];\n\n                          case 1:\n                            _b.sent();\n\n                            observer.next({\n                              type: ControlMessage.SYNC_ENGINE_OUTBOX_MUTATION_ENQUEUED,\n                              data: {\n                                model: model,\n                                element: element\n                              }\n                            });\n                            observer.next({\n                              type: ControlMessage.SYNC_ENGINE_OUTBOX_STATUS,\n                              data: {\n                                isEmpty: false\n                              }\n                            });\n                            return [4\n                            /*yield*/\n                            , startPromise];\n\n                          case 2:\n                            _b.sent();\n\n                            if (this.online) {\n                              this.mutationsProcessor.resume();\n                            }\n\n                            return [2\n                            /*return*/\n                            ];\n                        }\n                      });\n                    });\n                  }\n                });\n                observer.next({\n                  type: ControlMessage.SYNC_ENGINE_STORAGE_SUBSCRIBED\n                });\n                return [4\n                /*yield*/\n                , this.outbox.peek(this.storage)];\n\n              case 4:\n                hasMutationsInOutbox = _a.sent() === undefined;\n                observer.next({\n                  type: ControlMessage.SYNC_ENGINE_OUTBOX_STATUS,\n                  data: {\n                    isEmpty: hasMutationsInOutbox\n                  }\n                });\n                return [4\n                /*yield*/\n                , startPromise];\n\n              case 5:\n                _a.sent();\n\n                observer.next({\n                  type: ControlMessage.SYNC_ENGINE_READY\n                });\n                return [2\n                /*return*/\n                ];\n            }\n          });\n        });\n      })();\n\n      return function () {\n        subscriptions.forEach(function (sub) {\n          return sub.unsubscribe();\n        });\n      };\n    });\n  };\n\n  SyncEngine.prototype.getModelsMetadataWithNextFullSync = function (currentTimeStamp) {\n    return __awaiter(this, void 0, void 0, function () {\n      var modelLastSync, _a;\n\n      var _this = this;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = Map.bind;\n            return [4\n            /*yield*/\n            , this.getModelsMetadata()];\n\n          case 1:\n            modelLastSync = new (_a.apply(Map, [void 0, _b.sent().map(function (_a) {\n              var namespace = _a.namespace,\n                  model = _a.model,\n                  lastSync = _a.lastSync,\n                  lastFullSync = _a.lastFullSync,\n                  fullSyncInterval = _a.fullSyncInterval,\n                  lastSyncPredicate = _a.lastSyncPredicate;\n              var nextFullSync = lastFullSync + fullSyncInterval;\n              var syncFrom = !lastFullSync || nextFullSync < currentTimeStamp ? 0 // perform full sync if expired\n              : lastSync; // perform delta sync\n\n              return [_this.schema.namespaces[namespace].models[model], [namespace, syncFrom]];\n            })]))();\n            return [2\n            /*return*/\n            , modelLastSync];\n        }\n      });\n    });\n  };\n\n  SyncEngine.prototype.syncQueriesObservable = function () {\n    var _this = this;\n\n    if (!this.online) {\n      return Observable.of();\n    }\n\n    return new Observable(function (observer) {\n      var syncQueriesSubscription;\n      var waitTimeoutId;\n\n      (function () {\n        return __awaiter(_this, void 0, void 0, function () {\n          var _loop_1, this_1;\n\n          var _this = this;\n\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                _loop_1 = function () {\n                  var count, modelLastSync, paginatingModels, newestFullSyncStartedAt, theInterval, start, duration, newestStartedAt, msNextFullSync;\n                  return __generator(this, function (_a) {\n                    switch (_a.label) {\n                      case 0:\n                        count = new WeakMap();\n                        return [4\n                        /*yield*/\n                        , this_1.getModelsMetadataWithNextFullSync(Date.now())];\n\n                      case 1:\n                        modelLastSync = _a.sent();\n                        paginatingModels = new Set(modelLastSync.keys());\n                        return [4\n                        /*yield*/\n                        , new Promise(function (resolve) {\n                          syncQueriesSubscription = _this.syncQueriesProcessor.start(modelLastSync).subscribe({\n                            next: function (_a) {\n                              var namespace = _a.namespace,\n                                  modelDefinition = _a.modelDefinition,\n                                  items = _a.items,\n                                  done = _a.done,\n                                  startedAt = _a.startedAt,\n                                  isFullSync = _a.isFullSync;\n                              return __awaiter(_this, void 0, void 0, function () {\n                                var modelConstructor, modelName, modelMetadata_1, lastFullSync, fullSyncInterval, counts;\n\n                                var _this = this;\n\n                                return __generator(this, function (_b) {\n                                  switch (_b.label) {\n                                    case 0:\n                                      modelConstructor = this.userModelClasses[modelDefinition.name];\n\n                                      if (!count.has(modelConstructor)) {\n                                        count.set(modelConstructor, {\n                                          new: 0,\n                                          updated: 0,\n                                          deleted: 0\n                                        });\n                                        start = getNow();\n                                        newestStartedAt = newestStartedAt === undefined ? startedAt : Math.max(newestStartedAt, startedAt);\n                                      }\n                                      /**\n                                       * If there are mutations in the outbox for a given id, those need to be\n                                       * merged individually. Otherwise, we can merge them in batches.\n                                       */\n\n\n                                      return [4\n                                      /*yield*/\n                                      , this.storage.runExclusive(function (storage) {\n                                        return __awaiter(_this, void 0, void 0, function () {\n                                          var idsInOutbox, oneByOne, page, opTypeCount, oneByOne_1, oneByOne_1_1, item, opType, e_1_1, _a, _b, _c, counts;\n\n                                          var e_1, _d;\n\n                                          return __generator(this, function (_e) {\n                                            switch (_e.label) {\n                                              case 0:\n                                                return [4\n                                                /*yield*/\n                                                , this.outbox.getModelIds(storage)];\n\n                                              case 1:\n                                                idsInOutbox = _e.sent();\n                                                oneByOne = [];\n                                                page = items.filter(function (item) {\n                                                  if (!idsInOutbox.has(item.id)) {\n                                                    return true;\n                                                  }\n\n                                                  oneByOne.push(item);\n                                                  return false;\n                                                });\n                                                opTypeCount = [];\n                                                _e.label = 2;\n\n                                              case 2:\n                                                _e.trys.push([2, 7, 8, 9]);\n\n                                                oneByOne_1 = __values(oneByOne), oneByOne_1_1 = oneByOne_1.next();\n                                                _e.label = 3;\n\n                                              case 3:\n                                                if (!!oneByOne_1_1.done) return [3\n                                                /*break*/\n                                                , 6];\n                                                item = oneByOne_1_1.value;\n                                                return [4\n                                                /*yield*/\n                                                , this.modelMerger.merge(storage, item)];\n\n                                              case 4:\n                                                opType = _e.sent();\n\n                                                if (opType !== undefined) {\n                                                  opTypeCount.push([item, opType]);\n                                                }\n\n                                                _e.label = 5;\n\n                                              case 5:\n                                                oneByOne_1_1 = oneByOne_1.next();\n                                                return [3\n                                                /*break*/\n                                                , 3];\n\n                                              case 6:\n                                                return [3\n                                                /*break*/\n                                                , 9];\n\n                                              case 7:\n                                                e_1_1 = _e.sent();\n                                                e_1 = {\n                                                  error: e_1_1\n                                                };\n                                                return [3\n                                                /*break*/\n                                                , 9];\n\n                                              case 8:\n                                                try {\n                                                  if (oneByOne_1_1 && !oneByOne_1_1.done && (_d = oneByOne_1.return)) _d.call(oneByOne_1);\n                                                } finally {\n                                                  if (e_1) throw e_1.error;\n                                                }\n\n                                                return [7\n                                                /*endfinally*/\n                                                ];\n\n                                              case 9:\n                                                _b = (_a = opTypeCount.push).apply;\n                                                _c = [opTypeCount];\n                                                return [4\n                                                /*yield*/\n                                                , this.modelMerger.mergePage(storage, modelConstructor, page)];\n\n                                              case 10:\n                                                _b.apply(_a, _c.concat([__spread.apply(void 0, [_e.sent()])]));\n\n                                                counts = count.get(modelConstructor);\n                                                opTypeCount.forEach(function (_a) {\n                                                  var _b = __read(_a, 2),\n                                                      opType = _b[1];\n\n                                                  switch (opType) {\n                                                    case OpType.INSERT:\n                                                      counts.new++;\n                                                      break;\n\n                                                    case OpType.UPDATE:\n                                                      counts.updated++;\n                                                      break;\n\n                                                    case OpType.DELETE:\n                                                      counts.deleted++;\n                                                      break;\n\n                                                    default:\n                                                      exhaustiveCheck(opType);\n                                                  }\n                                                });\n                                                return [2\n                                                /*return*/\n                                                ];\n                                            }\n                                          });\n                                        });\n                                      })];\n\n                                    case 1:\n                                      /**\n                                       * If there are mutations in the outbox for a given id, those need to be\n                                       * merged individually. Otherwise, we can merge them in batches.\n                                       */\n                                      _b.sent();\n\n                                      if (!done) return [3\n                                      /*break*/\n                                      , 4];\n                                      modelName = modelDefinition.name;\n                                      return [4\n                                      /*yield*/\n                                      , this.getModelMetadata(namespace, modelName)];\n\n                                    case 2:\n                                      modelMetadata_1 = _b.sent();\n                                      lastFullSync = modelMetadata_1.lastFullSync, fullSyncInterval = modelMetadata_1.fullSyncInterval;\n                                      theInterval = fullSyncInterval;\n                                      newestFullSyncStartedAt = newestFullSyncStartedAt === undefined ? lastFullSync : Math.max(newestFullSyncStartedAt, isFullSync ? startedAt : lastFullSync);\n                                      modelMetadata_1 = this.modelClasses.ModelMetadata.copyOf(modelMetadata_1, function (draft) {\n                                        draft.lastSync = startedAt;\n                                        draft.lastFullSync = isFullSync ? startedAt : modelMetadata_1.lastFullSync;\n                                      });\n                                      return [4\n                                      /*yield*/\n                                      , this.storage.save(modelMetadata_1, undefined, ownSymbol)];\n\n                                    case 3:\n                                      _b.sent();\n\n                                      counts = count.get(modelConstructor);\n                                      this.modelSyncedStatus.set(modelConstructor, true);\n                                      observer.next({\n                                        type: ControlMessage.SYNC_ENGINE_MODEL_SYNCED,\n                                        data: {\n                                          model: modelConstructor,\n                                          isFullSync: isFullSync,\n                                          isDeltaSync: !isFullSync,\n                                          counts: counts\n                                        }\n                                      });\n                                      paginatingModels.delete(modelDefinition);\n\n                                      if (paginatingModels.size === 0) {\n                                        duration = getNow() - start;\n                                        resolve();\n                                        observer.next({\n                                          type: ControlMessage.SYNC_ENGINE_SYNC_QUERIES_READY\n                                        });\n                                        syncQueriesSubscription.unsubscribe();\n                                      }\n\n                                      _b.label = 4;\n\n                                    case 4:\n                                      return [2\n                                      /*return*/\n                                      ];\n                                  }\n                                });\n                              });\n                            },\n                            error: function (error) {\n                              observer.error(error);\n                            }\n                          });\n                          observer.next({\n                            type: ControlMessage.SYNC_ENGINE_SYNC_QUERIES_STARTED,\n                            data: {\n                              models: Array.from(paginatingModels).map(function (_a) {\n                                var name = _a.name;\n                                return name;\n                              })\n                            }\n                          });\n                        })];\n\n                      case 2:\n                        _a.sent();\n\n                        msNextFullSync = newestFullSyncStartedAt + theInterval - (newestStartedAt + duration);\n                        logger.debug(\"Next fullSync in \" + msNextFullSync / 1000 + \" seconds. (\" + new Date(Date.now() + msNextFullSync) + \")\");\n                        return [4\n                        /*yield*/\n                        , new Promise(function (res) {\n                          waitTimeoutId = setTimeout(res, msNextFullSync);\n                        })];\n\n                      case 3:\n                        _a.sent();\n\n                        return [2\n                        /*return*/\n                        ];\n                    }\n                  });\n                };\n\n                this_1 = this;\n                _a.label = 1;\n\n              case 1:\n                if (!!observer.closed) return [3\n                /*break*/\n                , 3];\n                return [5\n                /*yield**/\n                , _loop_1()];\n\n              case 2:\n                _a.sent();\n\n                return [3\n                /*break*/\n                , 1];\n\n              case 3:\n                return [2\n                /*return*/\n                ];\n            }\n          });\n        });\n      })();\n\n      return function () {\n        if (syncQueriesSubscription) {\n          syncQueriesSubscription.unsubscribe();\n        }\n\n        if (waitTimeoutId) {\n          clearTimeout(waitTimeoutId);\n        }\n      };\n    });\n  };\n\n  SyncEngine.prototype.disconnectionHandler = function () {\n    var _this = this;\n\n    return function (msg) {\n      // This implementation is tied to AWSAppSyncRealTimeProvider 'Connection closed', 'Timeout disconnect' msg\n      if (PUBSUB_CONTROL_MSG.CONNECTION_CLOSED === msg || PUBSUB_CONTROL_MSG.TIMEOUT_DISCONNECT === msg) {\n        _this.datastoreConnectivity.socketDisconnected();\n      }\n    };\n  };\n\n  SyncEngine.prototype.unsubscribeConnectivity = function () {\n    this.datastoreConnectivity.unsubscribe();\n  };\n\n  SyncEngine.prototype.setupModels = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var fullSyncInterval, ModelMetadata, models, savedModel, promises, result, _a, _b, modelMetadata, modelName, e_2_1;\n\n      var e_2, _c;\n\n      var _this = this;\n\n      return __generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            fullSyncInterval = params.fullSyncInterval;\n            ModelMetadata = this.modelClasses.ModelMetadata;\n            models = [];\n            Object.values(this.schema.namespaces).forEach(function (namespace) {\n              Object.values(namespace.models).filter(function (_a) {\n                var syncable = _a.syncable;\n                return syncable;\n              }).forEach(function (model) {\n                models.push([namespace.name, model]);\n\n                if (namespace.name === USER) {\n                  var modelConstructor = _this.userModelClasses[model.name];\n\n                  _this.modelSyncedStatus.set(modelConstructor, false);\n                }\n              });\n            });\n            promises = models.map(function (_a) {\n              var _b = __read(_a, 2),\n                  namespace = _b[0],\n                  model = _b[1];\n\n              return __awaiter(_this, void 0, void 0, function () {\n                var modelMetadata, syncPredicate, lastSyncPredicate, prevSyncPredicate, syncPredicateUpdated_1;\n\n                var _c, _d, _e, _f;\n\n                return __generator(this, function (_g) {\n                  switch (_g.label) {\n                    case 0:\n                      return [4\n                      /*yield*/\n                      , this.getModelMetadata(namespace, model.name)];\n\n                    case 1:\n                      modelMetadata = _g.sent();\n                      syncPredicate = ModelPredicateCreator.getPredicates(this.syncPredicates.get(model), false);\n                      lastSyncPredicate = syncPredicate ? JSON.stringify(syncPredicate) : null;\n                      if (!(modelMetadata === undefined)) return [3\n                      /*break*/\n                      , 3];\n                      return [4\n                      /*yield*/\n                      , this.storage.save(this.modelInstanceCreator(ModelMetadata, {\n                        model: model.name,\n                        namespace: namespace,\n                        lastSync: null,\n                        fullSyncInterval: fullSyncInterval,\n                        lastFullSync: null,\n                        lastSyncPredicate: lastSyncPredicate\n                      }), undefined, ownSymbol)];\n\n                    case 2:\n                      _c = __read.apply(void 0, [_g.sent(), 1]), _d = __read(_c[0], 1), savedModel = _d[0];\n                      return [3\n                      /*break*/\n                      , 5];\n\n                    case 3:\n                      prevSyncPredicate = modelMetadata.lastSyncPredicate ? modelMetadata.lastSyncPredicate : null;\n                      syncPredicateUpdated_1 = prevSyncPredicate !== lastSyncPredicate;\n                      return [4\n                      /*yield*/\n                      , this.storage.save(this.modelClasses.ModelMetadata.copyOf(modelMetadata, function (draft) {\n                        draft.fullSyncInterval = fullSyncInterval; // perform a base sync if the syncPredicate changed in between calls to DataStore.start\n                        // ensures that the local store contains all the data specified by the syncExpression\n\n                        if (syncPredicateUpdated_1) {\n                          draft.lastSync = null;\n                          draft.lastFullSync = null;\n                          draft.lastSyncPredicate = lastSyncPredicate;\n                        }\n                      }))];\n\n                    case 4:\n                      _e = __read.apply(void 0, [_g.sent(), 1]), _f = __read(_e[0], 1), savedModel = _f[0];\n                      _g.label = 5;\n\n                    case 5:\n                      return [2\n                      /*return*/\n                      , savedModel];\n                  }\n                });\n              });\n            });\n            result = {};\n            _d.label = 1;\n\n          case 1:\n            _d.trys.push([1, 6, 7, 8]);\n\n            return [4\n            /*yield*/\n            , Promise.all(promises)];\n\n          case 2:\n            _a = __values.apply(void 0, [_d.sent()]), _b = _a.next();\n            _d.label = 3;\n\n          case 3:\n            if (!!_b.done) return [3\n            /*break*/\n            , 5];\n            modelMetadata = _b.value;\n            modelName = modelMetadata.model;\n            result[modelName] = modelMetadata;\n            _d.label = 4;\n\n          case 4:\n            _b = _a.next();\n            return [3\n            /*break*/\n            , 3];\n\n          case 5:\n            return [3\n            /*break*/\n            , 8];\n\n          case 6:\n            e_2_1 = _d.sent();\n            e_2 = {\n              error: e_2_1\n            };\n            return [3\n            /*break*/\n            , 8];\n\n          case 7:\n            try {\n              if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n            } finally {\n              if (e_2) throw e_2.error;\n            }\n\n            return [7\n            /*endfinally*/\n            ];\n\n          case 8:\n            return [2\n            /*return*/\n            , result];\n        }\n      });\n    });\n  };\n\n  SyncEngine.prototype.getModelsMetadata = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var ModelMetadata, modelsMetadata;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            ModelMetadata = this.modelClasses.ModelMetadata;\n            return [4\n            /*yield*/\n            , this.storage.query(ModelMetadata)];\n\n          case 1:\n            modelsMetadata = _a.sent();\n            return [2\n            /*return*/\n            , modelsMetadata];\n        }\n      });\n    });\n  };\n\n  SyncEngine.prototype.getModelMetadata = function (namespace, model) {\n    return __awaiter(this, void 0, void 0, function () {\n      var ModelMetadata, predicate, _a, modelMetadata;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            ModelMetadata = this.modelClasses.ModelMetadata;\n            predicate = ModelPredicateCreator.createFromExisting(this.schema.namespaces[SYNC].models[ModelMetadata.name], function (c) {\n              return c.namespace('eq', namespace).model('eq', model);\n            });\n            return [4\n            /*yield*/\n            , this.storage.query(ModelMetadata, predicate, {\n              page: 0,\n              limit: 1\n            })];\n\n          case 1:\n            _a = __read.apply(void 0, [_b.sent(), 1]), modelMetadata = _a[0];\n            return [2\n            /*return*/\n            , modelMetadata];\n        }\n      });\n    });\n  };\n\n  SyncEngine.prototype.getModelDefinition = function (modelConstructor) {\n    var namespaceName = this.namespaceResolver(modelConstructor);\n    var modelDefinition = this.schema.namespaces[namespaceName].models[modelConstructor.name];\n    return modelDefinition;\n  };\n\n  SyncEngine.getNamespace = function () {\n    var namespace = {\n      name: SYNC,\n      relationships: {},\n      enums: {\n        OperationType: {\n          name: 'OperationType',\n          values: ['CREATE', 'UPDATE', 'DELETE']\n        }\n      },\n      nonModels: {},\n      models: {\n        MutationEvent: {\n          name: 'MutationEvent',\n          pluralName: 'MutationEvents',\n          syncable: false,\n          fields: {\n            id: {\n              name: 'id',\n              type: 'ID',\n              isRequired: true,\n              isArray: false\n            },\n            model: {\n              name: 'model',\n              type: 'String',\n              isRequired: true,\n              isArray: false\n            },\n            data: {\n              name: 'data',\n              type: 'String',\n              isRequired: true,\n              isArray: false\n            },\n            modelId: {\n              name: 'modelId',\n              type: 'String',\n              isRequired: true,\n              isArray: false\n            },\n            operation: {\n              name: 'operation',\n              type: {\n                enum: 'Operationtype'\n              },\n              isArray: false,\n              isRequired: true\n            },\n            condition: {\n              name: 'condition',\n              type: 'String',\n              isArray: false,\n              isRequired: true\n            }\n          }\n        },\n        ModelMetadata: {\n          name: 'ModelMetadata',\n          pluralName: 'ModelsMetadata',\n          syncable: false,\n          fields: {\n            id: {\n              name: 'id',\n              type: 'ID',\n              isRequired: true,\n              isArray: false\n            },\n            namespace: {\n              name: 'namespace',\n              type: 'String',\n              isRequired: true,\n              isArray: false\n            },\n            model: {\n              name: 'model',\n              type: 'String',\n              isRequired: true,\n              isArray: false\n            },\n            lastSync: {\n              name: 'lastSync',\n              type: 'Int',\n              isRequired: false,\n              isArray: false\n            },\n            lastFullSync: {\n              name: 'lastFullSync',\n              type: 'Int',\n              isRequired: false,\n              isArray: false\n            },\n            fullSyncInterval: {\n              name: 'fullSyncInterval',\n              type: 'Int',\n              isRequired: true,\n              isArray: false\n            },\n            lastSyncPredicate: {\n              name: 'lastSyncPredicate',\n              type: 'String',\n              isRequired: false,\n              isArray: false\n            }\n          }\n        }\n      }\n    };\n    return namespace;\n  };\n\n  return SyncEngine;\n}();\n\nexport { SyncEngine };","map":{"version":3,"mappings":"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","names":["browserOrNode","ConsoleLogger","Logger","CONTROL_MSG","PUBSUB_CONTROL_MSG","Observable","ModelPredicateCreator","OpType","exhaustiveCheck","getNow","SYNC","USER","DataStoreConnectivity","ModelMerger","MutationEventOutbox","MutationProcessor","SubscriptionProcessor","SyncProcessor","createMutationInstanceFromModelOperation","predicateToGraphQLCondition","logger","ownSymbol","Symbol","ControlMessage","schema","namespaceResolver","modelClasses","userModelClasses","storage","modelInstanceCreator","maxRecordsToSync","syncPageSize","conflictHandler","errorHandler","syncPredicates","amplifyConfig","authModeStrategy","WeakMap","MutationEvent","outbox","modelMerger","syncQueriesProcessor","subscriptionsProcessor","mutationsProcessor","datastoreConnectivity","SyncEngine","modelConstructor","modelSyncedStatus","get","params","log","subscriptions","setupModels","_a","observer","error","err_1","startPromise","Promise","_this","status","subscribe","online","next","type","SYNC_ENGINE_NETWORK_STATUS","data","active","dataSubsObservable","isNode","warn","_b","ctlSubsObservable_1","resolve","reject","ctlSubsSubscription","msg","CONNECTED","err","handleDisconnect","disconnectionHandler","push","_c","err_2","SYNC_ENGINE_SUBSCRIPTIONS_ESTABLISHED","syncQuerySubscription","syncQueriesObservable","SYNC_ENGINE_SYNC_QUERIES_READY","message","complete","error_1","start","modelDefinition","item","hasMore","name","model","runExclusive","merge","SYNC_ENGINE_OUTBOX_MUTATION_PROCESSED","element","SYNC_ENGINE_OUTBOX_STATUS","isEmpty","_transformerMutationType","forEach","unsubscribe","observe","filter","getModelDefinition","syncable","opType","condition","namespace","namespaces","MutationEventConstructor","graphQLCondition","mutationEvent","relationships","enqueue","SYNC_ENGINE_OUTBOX_MUTATION_ENQUEUED","resume","SYNC_ENGINE_STORAGE_SUBSCRIBED","peek","hasMutationsInOutbox","undefined","SYNC_ENGINE_READY","currentTimeStamp","Map","getModelsMetadata","modelLastSync","map","lastSync","lastFullSync","fullSyncInterval","lastSyncPredicate","nextFullSync","syncFrom","models","of","syncQueriesSubscription","waitTimeoutId","count","this_1","getModelsMetadataWithNextFullSync","Date","now","paginatingModels","Set","keys","items","done","startedAt","isFullSync","has","set","new","updated","deleted","newestStartedAt","Math","max","getModelIds","idsInOutbox","_e","oneByOne","page","id","opTypeCount","oneByOne_1","oneByOne_1_1","apply","mergePage","counts","INSERT","UPDATE","DELETE","modelName","getModelMetadata","modelMetadata_1","theInterval","newestFullSyncStartedAt","ModelMetadata","copyOf","draft","save","SYNC_ENGINE_MODEL_SYNCED","isDeltaSync","delete","size","duration","SYNC_ENGINE_SYNC_QUERIES_STARTED","Array","from","msNextFullSync","debug","setTimeout","res","closed","clearTimeout","CONNECTION_CLOSED","TIMEOUT_DISCONNECT","socketDisconnected","Object","values","promises","modelMetadata","_g","syncPredicate","getPredicates","JSON","stringify","_d","savedModel","prevSyncPredicate","syncPredicateUpdated_1","_f","result","all","query","modelsMetadata","predicate","createFromExisting","limit","namespaceName","enums","OperationType","nonModels","pluralName","fields","isRequired","isArray","modelId","operation","enum"],"sources":["/Users/richards/node_modules/@aws-amplify/datastore/src/sync/index.ts"],"sourcesContent":["import { browserOrNode, ConsoleLogger as Logger } from '@aws-amplify/core';\nimport { CONTROL_MSG as PUBSUB_CONTROL_MSG } from '@aws-amplify/pubsub';\nimport Observable, { ZenObservable } from 'zen-observable-ts';\nimport { ModelInstanceCreator } from '../datastore/datastore';\nimport { ModelPredicateCreator } from '../predicates';\nimport { ExclusiveStorage as Storage } from '../storage/storage';\nimport {\n\tConflictHandler,\n\tControlMessageType,\n\tErrorHandler,\n\tInternalSchema,\n\tModelInit,\n\tModelInstanceMetadata,\n\tMutableModel,\n\tNamespaceResolver,\n\tOpType,\n\tPersistentModel,\n\tPersistentModelConstructor,\n\tSchemaModel,\n\tSchemaNamespace,\n\tTypeConstructorMap,\n\tModelPredicate,\n\tAuthModeStrategy,\n} from '../types';\nimport { exhaustiveCheck, getNow, SYNC, USER } from '../util';\nimport DataStoreConnectivity from './datastoreConnectivity';\nimport { ModelMerger } from './merger';\nimport { MutationEventOutbox } from './outbox';\nimport { MutationProcessor } from './processors/mutation';\nimport { CONTROL_MSG, SubscriptionProcessor } from './processors/subscription';\nimport { SyncProcessor } from './processors/sync';\nimport {\n\tcreateMutationInstanceFromModelOperation,\n\tpredicateToGraphQLCondition,\n\tTransformerMutationType,\n} from './utils';\n\nconst { isNode } = browserOrNode();\nconst logger = new Logger('DataStore');\n\nconst ownSymbol = Symbol('sync');\n\ntype StartParams = {\n\tfullSyncInterval: number;\n};\n\nexport declare class MutationEvent {\n\tconstructor(init: ModelInit<MutationEvent>);\n\tstatic copyOf(\n\t\tsrc: MutationEvent,\n\t\tmutator: (draft: MutableModel<MutationEvent>) => void | MutationEvent\n\t): MutationEvent;\n\tpublic readonly id: string;\n\tpublic readonly model: string;\n\tpublic readonly operation: TransformerMutationType;\n\tpublic readonly modelId: string;\n\tpublic readonly condition: string;\n\tpublic data: string;\n}\n\ndeclare class ModelMetadata {\n\tconstructor(init: ModelInit<ModelMetadata>);\n\tstatic copyOf(\n\t\tsrc: ModelMetadata,\n\t\tmutator: (draft: MutableModel<ModelMetadata>) => void | ModelMetadata\n\t): ModelMetadata;\n\tpublic readonly id: string;\n\tpublic readonly namespace: string;\n\tpublic readonly model: string;\n\tpublic readonly fullSyncInterval: number;\n\tpublic readonly lastSync?: number;\n\tpublic readonly lastFullSync?: number;\n\tpublic readonly lastSyncPredicate?: null | string;\n}\n\nexport enum ControlMessage {\n\tSYNC_ENGINE_STORAGE_SUBSCRIBED = 'storageSubscribed',\n\tSYNC_ENGINE_SUBSCRIPTIONS_ESTABLISHED = 'subscriptionsEstablished',\n\tSYNC_ENGINE_SYNC_QUERIES_STARTED = 'syncQueriesStarted',\n\tSYNC_ENGINE_SYNC_QUERIES_READY = 'syncQueriesReady',\n\tSYNC_ENGINE_MODEL_SYNCED = 'modelSynced',\n\tSYNC_ENGINE_OUTBOX_MUTATION_ENQUEUED = 'outboxMutationEnqueued',\n\tSYNC_ENGINE_OUTBOX_MUTATION_PROCESSED = 'outboxMutationProcessed',\n\tSYNC_ENGINE_OUTBOX_STATUS = 'outboxStatus',\n\tSYNC_ENGINE_NETWORK_STATUS = 'networkStatus',\n\tSYNC_ENGINE_READY = 'ready',\n}\n\nexport class SyncEngine {\n\tprivate online = false;\n\n\tprivate readonly syncQueriesProcessor: SyncProcessor;\n\tprivate readonly subscriptionsProcessor: SubscriptionProcessor;\n\tprivate readonly mutationsProcessor: MutationProcessor;\n\tprivate readonly modelMerger: ModelMerger;\n\tprivate readonly outbox: MutationEventOutbox;\n\tprivate readonly datastoreConnectivity: DataStoreConnectivity;\n\tprivate readonly modelSyncedStatus: WeakMap<\n\t\tPersistentModelConstructor<any>,\n\t\tboolean\n\t> = new WeakMap();\n\n\tpublic getModelSyncedStatus(\n\t\tmodelConstructor: PersistentModelConstructor<any>\n\t): boolean {\n\t\treturn this.modelSyncedStatus.get(modelConstructor);\n\t}\n\n\tconstructor(\n\t\tprivate readonly schema: InternalSchema,\n\t\tprivate readonly namespaceResolver: NamespaceResolver,\n\t\tprivate readonly modelClasses: TypeConstructorMap,\n\t\tprivate readonly userModelClasses: TypeConstructorMap,\n\t\tprivate readonly storage: Storage,\n\t\tprivate readonly modelInstanceCreator: ModelInstanceCreator,\n\t\tprivate readonly maxRecordsToSync: number,\n\t\tprivate readonly syncPageSize: number,\n\t\tconflictHandler: ConflictHandler,\n\t\terrorHandler: ErrorHandler,\n\t\tprivate readonly syncPredicates: WeakMap<SchemaModel, ModelPredicate<any>>,\n\t\tprivate readonly amplifyConfig: Record<string, any> = {},\n\t\tprivate readonly authModeStrategy: AuthModeStrategy\n\t) {\n\t\tconst MutationEvent = this.modelClasses[\n\t\t\t'MutationEvent'\n\t\t] as PersistentModelConstructor<any>;\n\n\t\tthis.outbox = new MutationEventOutbox(\n\t\t\tthis.schema,\n\t\t\tMutationEvent,\n\t\t\tmodelInstanceCreator,\n\t\t\townSymbol\n\t\t);\n\n\t\tthis.modelMerger = new ModelMerger(this.outbox, ownSymbol);\n\n\t\tthis.syncQueriesProcessor = new SyncProcessor(\n\t\t\tthis.schema,\n\t\t\tthis.syncPredicates,\n\t\t\tthis.amplifyConfig,\n\t\t\tthis.authModeStrategy\n\t\t);\n\t\tthis.subscriptionsProcessor = new SubscriptionProcessor(\n\t\t\tthis.schema,\n\t\t\tthis.syncPredicates,\n\t\t\tthis.amplifyConfig,\n\t\t\tthis.authModeStrategy\n\t\t);\n\t\tthis.mutationsProcessor = new MutationProcessor(\n\t\t\tthis.schema,\n\t\t\tthis.storage,\n\t\t\tthis.userModelClasses,\n\t\t\tthis.outbox,\n\t\t\tthis.modelInstanceCreator,\n\t\t\tMutationEvent,\n\t\t\tthis.amplifyConfig,\n\t\t\tthis.authModeStrategy,\n\t\t\tconflictHandler,\n\t\t\terrorHandler\n\t\t);\n\t\tthis.datastoreConnectivity = new DataStoreConnectivity();\n\t}\n\n\tstart(params: StartParams) {\n\t\treturn new Observable<ControlMessageType<ControlMessage>>(observer => {\n\t\t\tlogger.log('starting sync engine...');\n\n\t\t\tlet subscriptions: ZenObservable.Subscription[] = [];\n\n\t\t\t(async () => {\n\t\t\t\ttry {\n\t\t\t\t\tawait this.setupModels(params);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tobserver.error(err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst startPromise = new Promise(resolve => {\n\t\t\t\t\tthis.datastoreConnectivity.status().subscribe(async ({ online }) => {\n\t\t\t\t\t\t// From offline to online\n\t\t\t\t\t\tif (online && !this.online) {\n\t\t\t\t\t\t\tthis.online = online;\n\n\t\t\t\t\t\t\tobserver.next({\n\t\t\t\t\t\t\t\ttype: ControlMessage.SYNC_ENGINE_NETWORK_STATUS,\n\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\tactive: this.online,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\tlet ctlSubsObservable: Observable<CONTROL_MSG>;\n\t\t\t\t\t\t\tlet dataSubsObservable: Observable<[\n\t\t\t\t\t\t\t\tTransformerMutationType,\n\t\t\t\t\t\t\t\tSchemaModel,\n\t\t\t\t\t\t\t\tPersistentModel\n\t\t\t\t\t\t\t]>;\n\n\t\t\t\t\t\t\tif (isNode) {\n\t\t\t\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t\t\t\t'Realtime disabled when in a server-side environment'\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t//#region GraphQL Subscriptions\n\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t// const ctlObservable: Observable<CONTROL_MSG>\n\t\t\t\t\t\t\t\t\tctlSubsObservable,\n\t\t\t\t\t\t\t\t\t// const dataObservable: Observable<[TransformerMutationType, SchemaModel, Readonly<{\n\t\t\t\t\t\t\t\t\t// id: string;\n\t\t\t\t\t\t\t\t\t// } & Record<string, any>>]>\n\t\t\t\t\t\t\t\t\tdataSubsObservable,\n\t\t\t\t\t\t\t\t] = this.subscriptionsProcessor.start();\n\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tawait new Promise((resolve, reject) => {\n\t\t\t\t\t\t\t\t\t\tconst ctlSubsSubscription = ctlSubsObservable.subscribe({\n\t\t\t\t\t\t\t\t\t\t\tnext: msg => {\n\t\t\t\t\t\t\t\t\t\t\t\tif (msg === CONTROL_MSG.CONNECTED) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\terror: err => {\n\t\t\t\t\t\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\t\t\t\t\t\tconst handleDisconnect = this.disconnectionHandler();\n\t\t\t\t\t\t\t\t\t\t\t\thandleDisconnect(err);\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t\tsubscriptions.push(ctlSubsSubscription);\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t\tobserver.error(err);\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tlogger.log('Realtime ready');\n\n\t\t\t\t\t\t\t\tobserver.next({\n\t\t\t\t\t\t\t\t\ttype: ControlMessage.SYNC_ENGINE_SUBSCRIPTIONS_ESTABLISHED,\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t//#endregion\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t//#region Base & Sync queries\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tawait new Promise((resolve, reject) => {\n\t\t\t\t\t\t\t\t\tconst syncQuerySubscription = this.syncQueriesObservable().subscribe(\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tnext: message => {\n\t\t\t\t\t\t\t\t\t\t\t\tconst { type } = message;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype === ControlMessage.SYNC_ENGINE_SYNC_QUERIES_READY\n\t\t\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tobserver.next(message);\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tcomplete: () => {\n\t\t\t\t\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\terror: error => {\n\t\t\t\t\t\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\tif (syncQuerySubscription) {\n\t\t\t\t\t\t\t\t\t\tsubscriptions.push(syncQuerySubscription);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t\tobserver.error(error);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//#endregion\n\n\t\t\t\t\t\t\t//#region process mutations\n\t\t\t\t\t\t\tsubscriptions.push(\n\t\t\t\t\t\t\t\tthis.mutationsProcessor\n\t\t\t\t\t\t\t\t\t.start()\n\t\t\t\t\t\t\t\t\t.subscribe(({ modelDefinition, model: item, hasMore }) => {\n\t\t\t\t\t\t\t\t\t\tconst modelConstructor = this.userModelClasses[\n\t\t\t\t\t\t\t\t\t\t\tmodelDefinition.name\n\t\t\t\t\t\t\t\t\t\t] as PersistentModelConstructor<any>;\n\n\t\t\t\t\t\t\t\t\t\tconst model = this.modelInstanceCreator(\n\t\t\t\t\t\t\t\t\t\t\tmodelConstructor,\n\t\t\t\t\t\t\t\t\t\t\titem\n\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\tthis.storage.runExclusive(storage =>\n\t\t\t\t\t\t\t\t\t\t\tthis.modelMerger.merge(storage, model)\n\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\tobserver.next({\n\t\t\t\t\t\t\t\t\t\t\ttype:\n\t\t\t\t\t\t\t\t\t\t\t\tControlMessage.SYNC_ENGINE_OUTBOX_MUTATION_PROCESSED,\n\t\t\t\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\t\t\t\tmodel: modelConstructor,\n\t\t\t\t\t\t\t\t\t\t\t\telement: model,\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t\tobserver.next({\n\t\t\t\t\t\t\t\t\t\t\ttype: ControlMessage.SYNC_ENGINE_OUTBOX_STATUS,\n\t\t\t\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\t\t\t\tisEmpty: !hasMore,\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t//#endregion\n\n\t\t\t\t\t\t\t//#region Merge subscriptions buffer\n\t\t\t\t\t\t\t// TODO: extract to function\n\t\t\t\t\t\t\tif (!isNode) {\n\t\t\t\t\t\t\t\tsubscriptions.push(\n\t\t\t\t\t\t\t\t\tdataSubsObservable.subscribe(\n\t\t\t\t\t\t\t\t\t\t([_transformerMutationType, modelDefinition, item]) => {\n\t\t\t\t\t\t\t\t\t\t\tconst modelConstructor = this.userModelClasses[\n\t\t\t\t\t\t\t\t\t\t\t\tmodelDefinition.name\n\t\t\t\t\t\t\t\t\t\t\t] as PersistentModelConstructor<any>;\n\n\t\t\t\t\t\t\t\t\t\t\tconst model = this.modelInstanceCreator(\n\t\t\t\t\t\t\t\t\t\t\t\tmodelConstructor,\n\t\t\t\t\t\t\t\t\t\t\t\titem\n\t\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\t\tthis.storage.runExclusive(storage =>\n\t\t\t\t\t\t\t\t\t\t\t\tthis.modelMerger.merge(storage, model)\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//#endregion\n\t\t\t\t\t\t} else if (!online) {\n\t\t\t\t\t\t\tthis.online = online;\n\n\t\t\t\t\t\t\tobserver.next({\n\t\t\t\t\t\t\t\ttype: ControlMessage.SYNC_ENGINE_NETWORK_STATUS,\n\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\tactive: this.online,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\tsubscriptions.forEach(sub => sub.unsubscribe());\n\t\t\t\t\t\t\tsubscriptions = [];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t\tthis.storage\n\t\t\t\t\t.observe(null, null, ownSymbol)\n\t\t\t\t\t.filter(({ model }) => {\n\t\t\t\t\t\tconst modelDefinition = this.getModelDefinition(model);\n\n\t\t\t\t\t\treturn modelDefinition.syncable === true;\n\t\t\t\t\t})\n\t\t\t\t\t.subscribe({\n\t\t\t\t\t\tnext: async ({ opType, model, element, condition }) => {\n\t\t\t\t\t\t\tconst namespace = this.schema.namespaces[\n\t\t\t\t\t\t\t\tthis.namespaceResolver(model)\n\t\t\t\t\t\t\t];\n\t\t\t\t\t\t\tconst MutationEventConstructor = this.modelClasses[\n\t\t\t\t\t\t\t\t'MutationEvent'\n\t\t\t\t\t\t\t] as PersistentModelConstructor<MutationEvent>;\n\t\t\t\t\t\t\tconst graphQLCondition = predicateToGraphQLCondition(condition);\n\t\t\t\t\t\t\tconst mutationEvent = createMutationInstanceFromModelOperation(\n\t\t\t\t\t\t\t\tnamespace.relationships,\n\t\t\t\t\t\t\t\tthis.getModelDefinition(model),\n\t\t\t\t\t\t\t\topType,\n\t\t\t\t\t\t\t\tmodel,\n\t\t\t\t\t\t\t\telement,\n\t\t\t\t\t\t\t\tgraphQLCondition,\n\t\t\t\t\t\t\t\tMutationEventConstructor,\n\t\t\t\t\t\t\t\tthis.modelInstanceCreator\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tawait this.outbox.enqueue(this.storage, mutationEvent);\n\n\t\t\t\t\t\t\tobserver.next({\n\t\t\t\t\t\t\t\ttype: ControlMessage.SYNC_ENGINE_OUTBOX_MUTATION_ENQUEUED,\n\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\tmodel,\n\t\t\t\t\t\t\t\t\telement,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\tobserver.next({\n\t\t\t\t\t\t\t\ttype: ControlMessage.SYNC_ENGINE_OUTBOX_STATUS,\n\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\tisEmpty: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\tawait startPromise;\n\n\t\t\t\t\t\t\tif (this.online) {\n\t\t\t\t\t\t\t\tthis.mutationsProcessor.resume();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\n\t\t\t\tobserver.next({\n\t\t\t\t\ttype: ControlMessage.SYNC_ENGINE_STORAGE_SUBSCRIBED,\n\t\t\t\t});\n\n\t\t\t\tconst hasMutationsInOutbox =\n\t\t\t\t\t(await this.outbox.peek(this.storage)) === undefined;\n\t\t\t\tobserver.next({\n\t\t\t\t\ttype: ControlMessage.SYNC_ENGINE_OUTBOX_STATUS,\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tisEmpty: hasMutationsInOutbox,\n\t\t\t\t\t},\n\t\t\t\t});\n\n\t\t\t\tawait startPromise;\n\n\t\t\t\tobserver.next({\n\t\t\t\t\ttype: ControlMessage.SYNC_ENGINE_READY,\n\t\t\t\t});\n\t\t\t})();\n\n\t\t\treturn () => {\n\t\t\t\tsubscriptions.forEach(sub => sub.unsubscribe());\n\t\t\t};\n\t\t});\n\t}\n\n\tprivate async getModelsMetadataWithNextFullSync(\n\t\tcurrentTimeStamp: number\n\t): Promise<Map<SchemaModel, [string, number]>> {\n\t\tconst modelLastSync: Map<SchemaModel, [string, number]> = new Map(\n\t\t\t(await this.getModelsMetadata()).map(\n\t\t\t\t({\n\t\t\t\t\tnamespace,\n\t\t\t\t\tmodel,\n\t\t\t\t\tlastSync,\n\t\t\t\t\tlastFullSync,\n\t\t\t\t\tfullSyncInterval,\n\t\t\t\t\tlastSyncPredicate,\n\t\t\t\t}) => {\n\t\t\t\t\tconst nextFullSync = lastFullSync + fullSyncInterval;\n\t\t\t\t\tconst syncFrom =\n\t\t\t\t\t\t!lastFullSync || nextFullSync < currentTimeStamp\n\t\t\t\t\t\t\t? 0 // perform full sync if expired\n\t\t\t\t\t\t\t: lastSync; // perform delta sync\n\n\t\t\t\t\treturn [\n\t\t\t\t\t\tthis.schema.namespaces[namespace].models[model],\n\t\t\t\t\t\t[namespace, syncFrom],\n\t\t\t\t\t];\n\t\t\t\t}\n\t\t\t)\n\t\t);\n\n\t\treturn modelLastSync;\n\t}\n\n\tprivate syncQueriesObservable(): Observable<\n\t\tControlMessageType<ControlMessage>\n\t> {\n\t\tif (!this.online) {\n\t\t\treturn Observable.of<ControlMessageType<ControlMessage>>();\n\t\t}\n\n\t\treturn new Observable<ControlMessageType<ControlMessage>>(observer => {\n\t\t\tlet syncQueriesSubscription: ZenObservable.Subscription;\n\t\t\tlet waitTimeoutId: ReturnType<typeof setTimeout>;\n\n\t\t\t(async () => {\n\t\t\t\twhile (!observer.closed) {\n\t\t\t\t\tconst count: WeakMap<\n\t\t\t\t\t\tPersistentModelConstructor<any>,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnew: number;\n\t\t\t\t\t\t\tupdated: number;\n\t\t\t\t\t\t\tdeleted: number;\n\t\t\t\t\t\t}\n\t\t\t\t\t> = new WeakMap();\n\n\t\t\t\t\tconst modelLastSync = await this.getModelsMetadataWithNextFullSync(\n\t\t\t\t\t\tDate.now()\n\t\t\t\t\t);\n\t\t\t\t\tconst paginatingModels = new Set(modelLastSync.keys());\n\n\t\t\t\t\tlet newestFullSyncStartedAt: number;\n\t\t\t\t\tlet theInterval: number;\n\n\t\t\t\t\tlet start: number;\n\t\t\t\t\tlet duration: number;\n\t\t\t\t\tlet newestStartedAt: number;\n\t\t\t\t\tawait new Promise(resolve => {\n\t\t\t\t\t\tsyncQueriesSubscription = this.syncQueriesProcessor\n\t\t\t\t\t\t\t.start(modelLastSync)\n\t\t\t\t\t\t\t.subscribe({\n\t\t\t\t\t\t\t\tnext: async ({\n\t\t\t\t\t\t\t\t\tnamespace,\n\t\t\t\t\t\t\t\t\tmodelDefinition,\n\t\t\t\t\t\t\t\t\titems,\n\t\t\t\t\t\t\t\t\tdone,\n\t\t\t\t\t\t\t\t\tstartedAt,\n\t\t\t\t\t\t\t\t\tisFullSync,\n\t\t\t\t\t\t\t\t}) => {\n\t\t\t\t\t\t\t\t\tconst modelConstructor = this.userModelClasses[\n\t\t\t\t\t\t\t\t\t\tmodelDefinition.name\n\t\t\t\t\t\t\t\t\t] as PersistentModelConstructor<any>;\n\n\t\t\t\t\t\t\t\t\tif (!count.has(modelConstructor)) {\n\t\t\t\t\t\t\t\t\t\tcount.set(modelConstructor, {\n\t\t\t\t\t\t\t\t\t\t\tnew: 0,\n\t\t\t\t\t\t\t\t\t\t\tupdated: 0,\n\t\t\t\t\t\t\t\t\t\t\tdeleted: 0,\n\t\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t\tstart = getNow();\n\t\t\t\t\t\t\t\t\t\tnewestStartedAt =\n\t\t\t\t\t\t\t\t\t\t\tnewestStartedAt === undefined\n\t\t\t\t\t\t\t\t\t\t\t\t? startedAt\n\t\t\t\t\t\t\t\t\t\t\t\t: Math.max(newestStartedAt, startedAt);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t\t * If there are mutations in the outbox for a given id, those need to be\n\t\t\t\t\t\t\t\t\t * merged individually. Otherwise, we can merge them in batches.\n\t\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\t\tawait this.storage.runExclusive(async storage => {\n\t\t\t\t\t\t\t\t\t\tconst idsInOutbox = await this.outbox.getModelIds(storage);\n\n\t\t\t\t\t\t\t\t\t\tconst oneByOne: ModelInstanceMetadata[] = [];\n\t\t\t\t\t\t\t\t\t\tconst page = items.filter(item => {\n\t\t\t\t\t\t\t\t\t\t\tif (!idsInOutbox.has(item.id)) {\n\t\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\toneByOne.push(item);\n\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t\tconst opTypeCount: [any, OpType][] = [];\n\n\t\t\t\t\t\t\t\t\t\tfor (const item of oneByOne) {\n\t\t\t\t\t\t\t\t\t\t\tconst opType = await this.modelMerger.merge(\n\t\t\t\t\t\t\t\t\t\t\t\tstorage,\n\t\t\t\t\t\t\t\t\t\t\t\titem\n\t\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\t\tif (opType !== undefined) {\n\t\t\t\t\t\t\t\t\t\t\t\topTypeCount.push([item, opType]);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\topTypeCount.push(\n\t\t\t\t\t\t\t\t\t\t\t...(await this.modelMerger.mergePage(\n\t\t\t\t\t\t\t\t\t\t\t\tstorage,\n\t\t\t\t\t\t\t\t\t\t\t\tmodelConstructor,\n\t\t\t\t\t\t\t\t\t\t\t\tpage\n\t\t\t\t\t\t\t\t\t\t\t))\n\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\tconst counts = count.get(modelConstructor);\n\n\t\t\t\t\t\t\t\t\t\topTypeCount.forEach(([, opType]) => {\n\t\t\t\t\t\t\t\t\t\t\tswitch (opType) {\n\t\t\t\t\t\t\t\t\t\t\t\tcase OpType.INSERT:\n\t\t\t\t\t\t\t\t\t\t\t\t\tcounts.new++;\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\tcase OpType.UPDATE:\n\t\t\t\t\t\t\t\t\t\t\t\t\tcounts.updated++;\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\tcase OpType.DELETE:\n\t\t\t\t\t\t\t\t\t\t\t\t\tcounts.deleted++;\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\t\t\texhaustiveCheck(opType);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\tif (done) {\n\t\t\t\t\t\t\t\t\t\tconst { name: modelName } = modelDefinition;\n\n\t\t\t\t\t\t\t\t\t\t//#region update last sync for type\n\t\t\t\t\t\t\t\t\t\tlet modelMetadata = await this.getModelMetadata(\n\t\t\t\t\t\t\t\t\t\t\tnamespace,\n\t\t\t\t\t\t\t\t\t\t\tmodelName\n\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\tconst { lastFullSync, fullSyncInterval } = modelMetadata;\n\n\t\t\t\t\t\t\t\t\t\ttheInterval = fullSyncInterval;\n\n\t\t\t\t\t\t\t\t\t\tnewestFullSyncStartedAt =\n\t\t\t\t\t\t\t\t\t\t\tnewestFullSyncStartedAt === undefined\n\t\t\t\t\t\t\t\t\t\t\t\t? lastFullSync\n\t\t\t\t\t\t\t\t\t\t\t\t: Math.max(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnewestFullSyncStartedAt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tisFullSync ? startedAt : lastFullSync\n\t\t\t\t\t\t\t\t\t\t\t\t  );\n\n\t\t\t\t\t\t\t\t\t\tmodelMetadata = (this.modelClasses\n\t\t\t\t\t\t\t\t\t\t\t.ModelMetadata as PersistentModelConstructor<any>).copyOf(\n\t\t\t\t\t\t\t\t\t\t\tmodelMetadata,\n\t\t\t\t\t\t\t\t\t\t\tdraft => {\n\t\t\t\t\t\t\t\t\t\t\t\tdraft.lastSync = startedAt;\n\t\t\t\t\t\t\t\t\t\t\t\tdraft.lastFullSync = isFullSync\n\t\t\t\t\t\t\t\t\t\t\t\t\t? startedAt\n\t\t\t\t\t\t\t\t\t\t\t\t\t: modelMetadata.lastFullSync;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\tawait this.storage.save(\n\t\t\t\t\t\t\t\t\t\t\tmodelMetadata,\n\t\t\t\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\t\t\t\townSymbol\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t//#endregion\n\n\t\t\t\t\t\t\t\t\t\tconst counts = count.get(modelConstructor);\n\n\t\t\t\t\t\t\t\t\t\tthis.modelSyncedStatus.set(modelConstructor, true);\n\n\t\t\t\t\t\t\t\t\t\tobserver.next({\n\t\t\t\t\t\t\t\t\t\t\ttype: ControlMessage.SYNC_ENGINE_MODEL_SYNCED,\n\t\t\t\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\t\t\t\tmodel: modelConstructor,\n\t\t\t\t\t\t\t\t\t\t\t\tisFullSync,\n\t\t\t\t\t\t\t\t\t\t\t\tisDeltaSync: !isFullSync,\n\t\t\t\t\t\t\t\t\t\t\t\tcounts,\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t\tpaginatingModels.delete(modelDefinition);\n\n\t\t\t\t\t\t\t\t\t\tif (paginatingModels.size === 0) {\n\t\t\t\t\t\t\t\t\t\t\tduration = getNow() - start;\n\t\t\t\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t\t\t\t\tobserver.next({\n\t\t\t\t\t\t\t\t\t\t\t\ttype: ControlMessage.SYNC_ENGINE_SYNC_QUERIES_READY,\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\tsyncQueriesSubscription.unsubscribe();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\terror: error => {\n\t\t\t\t\t\t\t\t\tobserver.error(error);\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\tobserver.next({\n\t\t\t\t\t\t\ttype: ControlMessage.SYNC_ENGINE_SYNC_QUERIES_STARTED,\n\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\tmodels: Array.from(paginatingModels).map(({ name }) => name),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\n\t\t\t\t\tconst msNextFullSync =\n\t\t\t\t\t\tnewestFullSyncStartedAt +\n\t\t\t\t\t\ttheInterval -\n\t\t\t\t\t\t(newestStartedAt + duration);\n\n\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t`Next fullSync in ${msNextFullSync / 1000} seconds. (${new Date(\n\t\t\t\t\t\t\tDate.now() + msNextFullSync\n\t\t\t\t\t\t)})`\n\t\t\t\t\t);\n\n\t\t\t\t\tawait new Promise(res => {\n\t\t\t\t\t\twaitTimeoutId = setTimeout(res, msNextFullSync);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t})();\n\n\t\t\treturn () => {\n\t\t\t\tif (syncQueriesSubscription) {\n\t\t\t\t\tsyncQueriesSubscription.unsubscribe();\n\t\t\t\t}\n\n\t\t\t\tif (waitTimeoutId) {\n\t\t\t\t\tclearTimeout(waitTimeoutId);\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t}\n\n\tprivate disconnectionHandler(): (msg: string) => void {\n\t\treturn (msg: string) => {\n\t\t\t// This implementation is tied to AWSAppSyncRealTimeProvider 'Connection closed', 'Timeout disconnect' msg\n\t\t\tif (\n\t\t\t\tPUBSUB_CONTROL_MSG.CONNECTION_CLOSED === msg ||\n\t\t\t\tPUBSUB_CONTROL_MSG.TIMEOUT_DISCONNECT === msg\n\t\t\t) {\n\t\t\t\tthis.datastoreConnectivity.socketDisconnected();\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic unsubscribeConnectivity() {\n\t\tthis.datastoreConnectivity.unsubscribe();\n\t}\n\n\tprivate async setupModels(params: StartParams) {\n\t\tconst { fullSyncInterval } = params;\n\t\tconst ModelMetadata = this.modelClasses\n\t\t\t.ModelMetadata as PersistentModelConstructor<ModelMetadata>;\n\n\t\tconst models: [string, SchemaModel][] = [];\n\t\tlet savedModel;\n\n\t\tObject.values(this.schema.namespaces).forEach(namespace => {\n\t\t\tObject.values(namespace.models)\n\t\t\t\t.filter(({ syncable }) => syncable)\n\t\t\t\t.forEach(model => {\n\t\t\t\t\tmodels.push([namespace.name, model]);\n\t\t\t\t\tif (namespace.name === USER) {\n\t\t\t\t\t\tconst modelConstructor = this.userModelClasses[\n\t\t\t\t\t\t\tmodel.name\n\t\t\t\t\t\t] as PersistentModelConstructor<any>;\n\t\t\t\t\t\tthis.modelSyncedStatus.set(modelConstructor, false);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t});\n\n\t\tconst promises = models.map(async ([namespace, model]) => {\n\t\t\tconst modelMetadata = await this.getModelMetadata(namespace, model.name);\n\t\t\tconst syncPredicate = ModelPredicateCreator.getPredicates(\n\t\t\t\tthis.syncPredicates.get(model),\n\t\t\t\tfalse\n\t\t\t);\n\t\t\tconst lastSyncPredicate = syncPredicate\n\t\t\t\t? JSON.stringify(syncPredicate)\n\t\t\t\t: null;\n\n\t\t\tif (modelMetadata === undefined) {\n\t\t\t\t[[savedModel]] = await this.storage.save(\n\t\t\t\t\tthis.modelInstanceCreator(ModelMetadata, {\n\t\t\t\t\t\tmodel: model.name,\n\t\t\t\t\t\tnamespace,\n\t\t\t\t\t\tlastSync: null,\n\t\t\t\t\t\tfullSyncInterval,\n\t\t\t\t\t\tlastFullSync: null,\n\t\t\t\t\t\tlastSyncPredicate,\n\t\t\t\t\t}),\n\t\t\t\t\tundefined,\n\t\t\t\t\townSymbol\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tconst prevSyncPredicate = modelMetadata.lastSyncPredicate\n\t\t\t\t\t? modelMetadata.lastSyncPredicate\n\t\t\t\t\t: null;\n\t\t\t\tconst syncPredicateUpdated = prevSyncPredicate !== lastSyncPredicate;\n\n\t\t\t\t[[savedModel]] = await this.storage.save(\n\t\t\t\t\t(this.modelClasses.ModelMetadata as PersistentModelConstructor<\n\t\t\t\t\t\tany\n\t\t\t\t\t>).copyOf(modelMetadata, draft => {\n\t\t\t\t\t\tdraft.fullSyncInterval = fullSyncInterval;\n\t\t\t\t\t\t// perform a base sync if the syncPredicate changed in between calls to DataStore.start\n\t\t\t\t\t\t// ensures that the local store contains all the data specified by the syncExpression\n\t\t\t\t\t\tif (syncPredicateUpdated) {\n\t\t\t\t\t\t\tdraft.lastSync = null;\n\t\t\t\t\t\t\tdraft.lastFullSync = null;\n\t\t\t\t\t\t\tdraft.lastSyncPredicate = lastSyncPredicate;\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn savedModel;\n\t\t});\n\n\t\tconst result: Record<string, ModelMetadata> = {};\n\t\tfor (const modelMetadata of await Promise.all(promises)) {\n\t\t\tconst { model: modelName } = modelMetadata;\n\n\t\t\tresult[modelName] = modelMetadata;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate async getModelsMetadata(): Promise<ModelMetadata[]> {\n\t\tconst ModelMetadata = this.modelClasses\n\t\t\t.ModelMetadata as PersistentModelConstructor<ModelMetadata>;\n\n\t\tconst modelsMetadata = await this.storage.query(ModelMetadata);\n\n\t\treturn modelsMetadata;\n\t}\n\n\tprivate async getModelMetadata(\n\t\tnamespace: string,\n\t\tmodel: string\n\t): Promise<ModelMetadata> {\n\t\tconst ModelMetadata = this.modelClasses\n\t\t\t.ModelMetadata as PersistentModelConstructor<ModelMetadata>;\n\n\t\tconst predicate = ModelPredicateCreator.createFromExisting<ModelMetadata>(\n\t\t\tthis.schema.namespaces[SYNC].models[ModelMetadata.name],\n\t\t\tc => c.namespace('eq', namespace).model('eq', model)\n\t\t);\n\n\t\tconst [modelMetadata] = await this.storage.query(ModelMetadata, predicate, {\n\t\t\tpage: 0,\n\t\t\tlimit: 1,\n\t\t});\n\n\t\treturn modelMetadata;\n\t}\n\n\tprivate getModelDefinition(\n\t\tmodelConstructor: PersistentModelConstructor<any>\n\t): SchemaModel {\n\t\tconst namespaceName = this.namespaceResolver(modelConstructor);\n\n\t\tconst modelDefinition = this.schema.namespaces[namespaceName].models[\n\t\t\tmodelConstructor.name\n\t\t];\n\n\t\treturn modelDefinition;\n\t}\n\n\tstatic getNamespace() {\n\t\tconst namespace: SchemaNamespace = {\n\t\t\tname: SYNC,\n\t\t\trelationships: {},\n\t\t\tenums: {\n\t\t\t\tOperationType: {\n\t\t\t\t\tname: 'OperationType',\n\t\t\t\t\tvalues: ['CREATE', 'UPDATE', 'DELETE'],\n\t\t\t\t},\n\t\t\t},\n\t\t\tnonModels: {},\n\t\t\tmodels: {\n\t\t\t\tMutationEvent: {\n\t\t\t\t\tname: 'MutationEvent',\n\t\t\t\t\tpluralName: 'MutationEvents',\n\t\t\t\t\tsyncable: false,\n\t\t\t\t\tfields: {\n\t\t\t\t\t\tid: {\n\t\t\t\t\t\t\tname: 'id',\n\t\t\t\t\t\t\ttype: 'ID',\n\t\t\t\t\t\t\tisRequired: true,\n\t\t\t\t\t\t\tisArray: false,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tmodel: {\n\t\t\t\t\t\t\tname: 'model',\n\t\t\t\t\t\t\ttype: 'String',\n\t\t\t\t\t\t\tisRequired: true,\n\t\t\t\t\t\t\tisArray: false,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\tname: 'data',\n\t\t\t\t\t\t\ttype: 'String',\n\t\t\t\t\t\t\tisRequired: true,\n\t\t\t\t\t\t\tisArray: false,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tmodelId: {\n\t\t\t\t\t\t\tname: 'modelId',\n\t\t\t\t\t\t\ttype: 'String',\n\t\t\t\t\t\t\tisRequired: true,\n\t\t\t\t\t\t\tisArray: false,\n\t\t\t\t\t\t},\n\t\t\t\t\t\toperation: {\n\t\t\t\t\t\t\tname: 'operation',\n\t\t\t\t\t\t\ttype: {\n\t\t\t\t\t\t\t\tenum: 'Operationtype',\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tisArray: false,\n\t\t\t\t\t\t\tisRequired: true,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcondition: {\n\t\t\t\t\t\t\tname: 'condition',\n\t\t\t\t\t\t\ttype: 'String',\n\t\t\t\t\t\t\tisArray: false,\n\t\t\t\t\t\t\tisRequired: true,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tModelMetadata: {\n\t\t\t\t\tname: 'ModelMetadata',\n\t\t\t\t\tpluralName: 'ModelsMetadata',\n\t\t\t\t\tsyncable: false,\n\t\t\t\t\tfields: {\n\t\t\t\t\t\tid: {\n\t\t\t\t\t\t\tname: 'id',\n\t\t\t\t\t\t\ttype: 'ID',\n\t\t\t\t\t\t\tisRequired: true,\n\t\t\t\t\t\t\tisArray: false,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnamespace: {\n\t\t\t\t\t\t\tname: 'namespace',\n\t\t\t\t\t\t\ttype: 'String',\n\t\t\t\t\t\t\tisRequired: true,\n\t\t\t\t\t\t\tisArray: false,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tmodel: {\n\t\t\t\t\t\t\tname: 'model',\n\t\t\t\t\t\t\ttype: 'String',\n\t\t\t\t\t\t\tisRequired: true,\n\t\t\t\t\t\t\tisArray: false,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tlastSync: {\n\t\t\t\t\t\t\tname: 'lastSync',\n\t\t\t\t\t\t\ttype: 'Int',\n\t\t\t\t\t\t\tisRequired: false,\n\t\t\t\t\t\t\tisArray: false,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tlastFullSync: {\n\t\t\t\t\t\t\tname: 'lastFullSync',\n\t\t\t\t\t\t\ttype: 'Int',\n\t\t\t\t\t\t\tisRequired: false,\n\t\t\t\t\t\t\tisArray: false,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfullSyncInterval: {\n\t\t\t\t\t\t\tname: 'fullSyncInterval',\n\t\t\t\t\t\t\ttype: 'Int',\n\t\t\t\t\t\t\tisRequired: true,\n\t\t\t\t\t\t\tisArray: false,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tlastSyncPredicate: {\n\t\t\t\t\t\t\tname: 'lastSyncPredicate',\n\t\t\t\t\t\t\ttype: 'String',\n\t\t\t\t\t\t\tisRequired: false,\n\t\t\t\t\t\t\tisArray: false,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t\treturn namespace;\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}